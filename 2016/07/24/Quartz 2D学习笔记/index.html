<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="去年的时候学习了一发Quartz Core，然而除了写几个demo也没有用上。现在想想都忘得差不多了，最近要开始写写博客记录自己的知识体系，就从捡起Quartz2D开始吧。
目录
什么的Quartz 2D？
使用姿势。
基本绘图案例。
UIView。
绘图进阶。
上下文栈（暂时不写）。
矩阵变换。

Demo 链接1.什么的Quartz2D？1.1 官方文档概念：
Quartz 2D是一个支持iO">
<meta property="og:type" content="article">
<meta property="og:title" content="Quartz 2D学习笔记">
<meta property="og:url" content="http://yoursite.com/2016/07/24/Quartz 2D学习笔记/index.html">
<meta property="og:site_name" content="果然是我">
<meta property="og:description" content="去年的时候学习了一发Quartz Core，然而除了写几个demo也没有用上。现在想想都忘得差不多了，最近要开始写写博客记录自己的知识体系，就从捡起Quartz2D开始吧。
目录
什么的Quartz 2D？
使用姿势。
基本绘图案例。
UIView。
绘图进阶。
上下文栈（暂时不写）。
矩阵变换。

Demo 链接1.什么的Quartz2D？1.1 官方文档概念：
Quartz 2D是一个支持iO">
<meta property="og:image" content="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图1.4.png?raw=true">
<meta property="og:image" content="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图2.1.png?raw=true">
<meta property="og:image" content="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图2.2.png?raw=true">
<meta property="og:image" content="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图3.1.png?raw=true">
<meta property="og:image" content="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图3.2.png?raw=true">
<meta property="og:image" content="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图3.3.png?raw=true">
<meta property="og:image" content="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图7.1.png?raw=true">
<meta property="og:image" content="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图7.2.png?raw=true">
<meta property="og:updated_time" content="2016-08-10T11:12:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Quartz 2D学习笔记">
<meta name="twitter:description" content="去年的时候学习了一发Quartz Core，然而除了写几个demo也没有用上。现在想想都忘得差不多了，最近要开始写写博客记录自己的知识体系，就从捡起Quartz2D开始吧。
目录
什么的Quartz 2D？
使用姿势。
基本绘图案例。
UIView。
绘图进阶。
上下文栈（暂时不写）。
矩阵变换。

Demo 链接1.什么的Quartz2D？1.1 官方文档概念：
Quartz 2D是一个支持iO">
<meta name="twitter:image" content="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图1.4.png?raw=true">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/07/24/Quartz 2D学习笔记/"/>

  <title> Quartz 2D学习笔记 | 果然是我 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">果然是我</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">记录生活。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Quartz 2D学习笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-24T19:49:15+08:00" content="2016-07-24">
              2016-07-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>去年的时候学习了一发Quartz Core，然而除了写几个demo也没有用上。现在想想都忘得差不多了，最近要开始写写博客记录自己的知识体系，就从捡起Quartz2D开始吧。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>什么的Quartz 2D？</li>
<li>使用姿势。</li>
<li>基本绘图案例。</li>
<li>UIView。</li>
<li>绘图进阶。</li>
<li>上下文栈（暂时不写）。</li>
<li>矩阵变换。</li>
</ul>
<h2 id="Demo-链接"><a href="#Demo-链接" class="headerlink" title="Demo 链接"></a><a href="https://github.com/wwhisdavid/Quartz2DDemo" target="_blank" rel="external">Demo 链接</a></h2><h2 id="1-什么的Quartz2D？"><a href="#1-什么的Quartz2D？" class="headerlink" title="1.什么的Quartz2D？"></a>1.什么的Quartz2D？</h2><h3 id="1-1-官方文档概念："><a href="#1-1-官方文档概念：" class="headerlink" title="1.1 官方文档概念："></a>1.1 官方文档概念：</h3><ul>
<li>Quartz 2D是一个支持iOS和MacOS的二维绘图引擎（C语音API）。</li>
<li>Quartz 2D在效率上可以充分地利用图像硬件。</li>
<li>我们可以使用其进行基于路径的绘制、可变透明度绘制、遮影绘制、平滑渲染、色彩管理等。</li>
<li>在iOS系统，Quartz 2D和所有图像渲染相关的技术一起发挥着作用。</li>
</ul>
<h3 id="1-2-几个重要概念"><a href="#1-2-几个重要概念" class="headerlink" title="1.2 几个重要概念"></a>1.2 几个重要概念</h3><ul>
<li>The Page –&gt; 页面(画布)</li>
</ul>
<pre><code>Quartz 2D使用画家的成像模型。在画家的模型中,每个连续的绘图操作一层“油漆”输出到“画布”,通常被称为一个页面。可以修改页面上的油漆覆盖更多的油漆通过额外的绘图操作。一个对象在页面上绘制不能，修改非通过覆盖更多的油漆。这个模型提供强大的原语允许构建非常复杂的图像从小画起。


简单的说，Quartz 2D的绘画模型是对实际绘画的抽象。通过不断往画板上绘制、覆盖来达到需要的结果。所以 ，绘制的顺序非常重要。而画布有可能是任何载体。


下图描述了这一模型，我们可见，绘图顺序影响了最终的结果。
![图1.1](https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图1.1.png?raw=true)
</code></pre><ul>
<li><p>Drawing Destinations: The Graphics Context –&gt; 画布的抽象：图形上下文</p>
<p>  图形上下文(CGContextRef)是一个不透明的数据类型(下文介绍这个概念)，其封装了Quartz 2D使用来画图像到输出设备的信息。在一个图形上下文的信息包括图形的绘图参数和于特定设备的表示页面上的元素。所有Quartz 2D涉及对象在上下文中。我们可以理解为他是你绘制的图像的数据、步骤的存放地，类似一种组件的概念，让程序员不需要考虑设备的兼容性，体现了一种封装的思想。</p>
</li>
</ul>
<pre><code>从下图可以看出，绘画元素封装在上下文中，供不同设备取用。    
![图1.2](https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图1.2.png?raw=true)
</code></pre><ul>
<li><p>Quartz 2D Opaque Data Types –&gt; 不透明数据类型</p>
<p>  所谓Opaque，即不透明的意思。个人认为表达了是一种封装的意思，即不为外部可见。Quartz 2D中的各种上下文都被称为不透明的。不透明数据类型指代的是那些上下文元数据类型，包括CGPathRef(路径)、CGImageRef(图片)、CGShadingRef(遮影)等，是绘图的元数据引用，可以看做绘图最基本的上下文元素。</p>
</li>
</ul>
<pre><code>下图为不透明数据类型的演示，即各种类型图案都是由不透明数据类型作为元数据构成。
![图1.3](https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图1.3.png?raw=true)
</code></pre><ul>
<li><p>Graphics States –&gt; 图形状态</p>
<p>  Quartz根据当前图形状态参数修改绘图操作的结果。简单来说，图形状态就是图形参数，状态决定了渲染结果。可以将其看做是图形上下文的某一时刻属性的集合。</p>
<p>  图形的图形上下文包含堆栈状态。当Quartz创建一个图形上下文,此时栈是空的。当你保存图形状态时, Quartz将当前图形状态的副本压入堆栈。当你恢复图形状态时, Quartz弹出图形状态堆栈的顶部。出现状态成为当前图形状态。</p>
<p>  要保存当前的图形状态,使用函数<code>CGContextSaveGState</code>来push当前图形状态的副本入堆栈。恢复先前保存的图形状态,使用功能<code>CGContextRestoreGState</code>替换当前的图形状态的图形状态堆栈的顶部。</p>
<p>  <code>注意,并不是当前的绘图环境的所有方面是图形的元素状态。</code>详细被作为状态的参数见下表。</p>
<p>  Params  | 。。。<br>  ————- | ————-<br>  Current transformation matrix (CTM)  | Content Cell<br>  Clipping area  | Content Cell<br>  Line: width, join, cap, dash, miter limit  | Content Cell<br>  Accuracy of curve estimation (flatness)  | Content Cell<br>  Anti-aliasing setting  | Content Cell<br>  Color: fill and stroke settings  | Content Cell<br>  Alpha value (transparency)  | Content Cell<br>  Rendering intent  | Content Cell<br>  Color space: fill and stroke settings  | Content Cell<br>  Text: font, font size, character spacing, text drawing mode  | Content Cell<br>  Blend mode  | Content Cell</p>
</li>
<li><p>Quartz 2D Coordinate Systems –&gt; 坐标系</p>
<p>  Quartz 2D的坐标系就是平常的几何坐标。坐标系的确定需要做到与设备无关，否则不同设备的像素要求可能会使图像失真。Quartz 2D在处理不同坐标体系和不同设备兼容时，使用了矩阵变换。</p>
<p>  下图为Quartz 2D中的坐标系。<br>  <img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图1.4.png?raw=true" alt="图1.4"></p>
<p>  需要注意，UIView使用的坐标系与Quartz不同，其以左上角为原点。</p>
</li>
</ul>
<ul>
<li><p>Memory Management: Object Ownership –&gt; 内存管理</p>
<p>  Quartz使用的是Core Foundation的内存管理模型，需要手动释放引用计数（ARC失效）。</p>
<p>  注意：如果你调用的函数有<code>copy</code>或<code>create</code>字眼，就表示你持有了该对象，需要手动去释放，对应的持有函数有CGColorSpaceRetain、CFRetain和释放函数CGColorSpaceRelease、 CFRelease。</p>
</li>
</ul>
<h2 id="2-使用姿势"><a href="#2-使用姿势" class="headerlink" title="2.使用姿势"></a>2.使用姿势</h2><p><strong>写在前面</strong>：所以Quartz 2D的API均要在UIView的<code>-(void)drawRect:(CGRect)rect;</code>方法中调用。这是因为Quartz中使用的上下文只能在该方法获取到，这是与UIView的生命周期相关，这个方法作为生命周期的回调来处理渲染。</p>
<h3 id="2-1-使用最原生API（比较繁琐）"><a href="#2-1-使用最原生API（比较繁琐）" class="headerlink" title="2.1 使用最原生API（比较繁琐）"></a>2.1 使用最原生API（比较繁琐）</h3><ul>
<li><p>从画一条线管中窥豹</p>
<pre><code>- (void)drawSimleLine{
    // 1.获取上下文（画作的封装）
    CGContextRef ctx = UIGraphicsGetCurrentContext();

    // 2.描述绘制线条
    CGMutablePathRef path = CGPathCreateMutable();

    // 3.设置起点 --&gt; 终点 --&gt; 渲染

    // 起点（30，30）
    CGPathMoveToPoint(path, NULL, 10, 50);

    // 添加一根线到某个终点（100，100）
    CGPathAddLineToPoint(path, NULL, 100, 100);

    // 4.把路径添加到上下文
    CGContextAddPath(ctx, path);

    // 5.渲染上下文
    CGContextStrokePath(ctx);

    // 6.内存释放
    CGPathRelease(path);
}
</code></pre></li>
<li><p>稍微简洁地画一条线</p>
<pre><code>- (void)drawSimleLine2{
    // 1.获取上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();

    // 2.描述路径
    // 设置起点、线、终点
    CGContextMoveToPoint(ctx, 20, 50);

    CGContextAddLineToPoint(ctx, 100, 100);

    // 3.渲染上下文
    CGContextStrokePath(ctx);
}
</code></pre></li>
<li><p>从上面的两条线，我们可以归纳出Quartz 2D画图的步骤：</p>
<pre><code>1.开启上下文 --&gt; 2.画图（点、线） --&gt; 3.渲染 --&gt; 4.内存释放
</code></pre></li>
<li><p>第一章中我们提到了上下文有一个重要特性：状态，我们可以理解为就某一时点上下文图像的熟悉。在<code>渲染上下文之前</code>我们可以通过设置状态改变最终渲染的样式：</p>
<pre><code>// 颜色
[[UIColor redColor] setStroke];

// 线宽
CGContextSetLineWidth(ctx, 5);

// 设置连接样式
CGContextSetLineJoin(ctx, kCGLineJoinBevel);

// 设置顶角样式
CGContextSetLineCap(ctx, kCGLineCapRound);
</code></pre></li>
<li><p>对于复杂的图像，光靠点和直线肯定是不够的，Quartz 2D支持通过控制点来绘制任意曲线：</p>
<pre><code>@param c   上下文
@param cpx 控制点x
@param cpy 控制点y
@param x   终点x
@param y   终点y
void CGContextAddQuadCurveToPoint(CGContextRef __nullable c,CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y);

关于控制点，可以见下图。
</code></pre></li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图2.1.png?raw=true" alt="图2.1"></p>
<h3 id="2-2-使用UIKit封装的API"><a href="#2-2-使用UIKit封装的API" class="headerlink" title="2.2 使用UIKit封装的API"></a>2.2 使用UIKit封装的API</h3><ul>
<li><p>Apple考虑到Quartz 2D使用的繁琐，和内存管理的问题。使用了<code>UIBezierPath</code>对Quartz 2D进行了封装，API十分面向对象。同样是画一条线：</p>
<pre><code>// 1.创建路径
UIBezierPath *path = [UIBezierPath bezierPath];

// 2.设置起点
[path moveToPoint:CGPointMake(30, 50)];

// 添加一根线到某个点
[path addLineToPoint:CGPointMake(100, 100)];
// 颜色
[[UIColor greenColor] set];
// 线宽
path.lineWidth = 10;

// 3.绘制路径
[path stroke];
</code></pre></li>
<li><p>画一些基本图形：</p>
<pre><code>// 1. 扇形
// 半径
CGFloat radius = rect.size.width * 0.5;
// 圆心
CGPoint center = CGPointMake(radius, radius);
// 圆弧终点角度
CGFloat endA = M_PI_2;
// 设置圆弧路径（其中clockwise:YES表示顺时针渲染）
UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius - 2 startAngle:- M_PI_2 endAngle:endA clockwise:YES];
// 从弧线上拉直线到圆心
[path addLineToPoint:center];
// 闭合扇形
[path closePath];
// 以填充方式渲染
[path fill];

// 2. 圆角矩形
// cornerRadius表示圆角半径
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 10, 100, 100) cornerRadius:30];
[path stroke];
</code></pre></li>
<li><p>当然，同样可以画复杂曲线（有两个极点）：</p>
</li>
</ul>
<pre><code>UIBezierPath *path = [UIBezierPath bezierPath];
// 设定起点
[path moveToPoint:CGPointMake(0,0)];
// 添加两个控制点
[path addCurveToPoint:CGPointMake(100, 100)
     controlPoint1:CGPointMake(50, 0)   
     controlPoint2:CGPointMake(0, 50)];            
// 添加终点
[path addLineToPoint:CGPointMake(0, 100)];
// 闭合
[path closePath];

大概结果见下图。
</code></pre><p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图2.2.png?raw=true" alt="图2.2"></p>
<h2 id="3-基本绘图案例"><a href="#3-基本绘图案例" class="headerlink" title="3.基本绘图案例"></a>3.基本绘图案例</h2><h3 id="3-1-进度圈绘制"><a href="#3-1-进度圈绘制" class="headerlink" title="3.1 进度圈绘制"></a>3.1 进度圈绘制</h3><ul>
<li><p>这里举一个使用UIBezierPath绘制一个类似ProgressHUB的进度圈。这里的思路来自于上文绘制圆弧，在<code>0°--&gt; 360°</code>范围内通过调用UIView的重绘回调（关于UIView的各种绘制时机，下一章介绍），不断在圆心向圆弧画线，且以fill方式渲染。具体代码如下：</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    CGFloat radius = rect.size.width * 0.5;
    CGPoint center = CGPointMake(radius, radius);
    // 此处的_progress是一个CGFloat变量（0，1），控制当前的进度
    CGFloat endA = - M_PI_2 + _progress * M_PI * 2;

    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius - 2 startAngle:-M_PI_2 endAngle:endA clockwise:YES];
    [path addLineToPoint:center];
    [path closePath];
    [path fill];
}

// 上述代码仅仅描述了一次扇形的微分绘制，外部通过设置_progress属性来重绘，代码如下：
- (void)setProgress:(CGFloat)progress
{
    _progress = progress;
    // 系统重绘
    [self setNeedsDisplay];
}
</code></pre></li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图3.1.png?raw=true" alt="图3.1"></p>
<h3 id="3-2-饼状图"><a href="#3-2-饼状图" class="headerlink" title="3.2 饼状图"></a>3.2 饼状图</h3><ul>
<li><p>本节说明如何使用UIBezierPath绘制饼状图。绘制饼状图的思路与绘制进度圈的思路基本一致，根据数据比值在360°范围内绘制各自扇形形成饼状图。代码如下：</p>
<pre><code>- (void)drawRect:(CGRect)rect{
    // 设置饼状数据，分别占10%、20%、70%
    NSArray *arr = [NSArray arrayWithObjects:@10, @20, @70, nil];
    CGFloat radius = rect.size.width * 0.5;
    CGPoint center = CGPointMake(radius, radius);

    __block CGFloat startA = 0;
    __block CGFloat angle = 0;
    __block CGFloat endA = 0;
    // 依次画数组中的扇形
    for (int i = 0; i &lt; arr.count; i++) {
        startA = endA;
        angle = [arr[i] integerValue] / 100.0 * M_PI * 2;
        endA = startA + angle;

        UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];

        [path addLineToPoint:center];
        // 设置颜色这里选择设置随机颜色，代码就不贴了。
        [[self colorRandom] set];
        [path fill];
    }
}
</code></pre></li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图3.2.png?raw=true" alt="图3.2"></p>
<h3 id="3-3-柱状图"><a href="#3-3-柱状图" class="headerlink" title="3.3 柱状图"></a>3.3 柱状图</h3><ul>
<li><p>本节说明如何使用UIBezierPath绘制柱状图，通过排布矩形实现：</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    NSArray *arr = @[@10, @20, @30, @15];

    CGFloat x = 0;
    CGFloat y = 0;
    CGFloat w = 0;
    CGFloat h = 0;

    for (int i = 0; i &lt; arr.count; i++) {
        w = rect.size.width / (2 * arr.count - 1);
        x = 2 * w * i;
        h = [arr[i] floatValue] / 100.0 * rect.size.height;
        y = rect.size.height - h;

        UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(x, y, w, h)];

        [[self colorRandom] set];
        [path fill];
</code></pre></li>
</ul>
<pre><code>    }
} 
</code></pre><p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图3.3.png?raw=true" alt="图3.3"></p>
<h2 id="4-UIView的生命周期"><a href="#4-UIView的生命周期" class="headerlink" title="4.UIView的生命周期"></a>4.UIView的生命周期</h2><p>这篇文章抽空来谈谈UIView。UIView是我们UI编程的基础与核心，也是Quartz 2D的渲染载体。</p>
<h3 id="4-1-不常用属性介绍"><a href="#4-1-不常用属性介绍" class="headerlink" title="4.1 不常用属性介绍"></a>4.1 不常用属性介绍</h3><ul>
<li><p>@property(nonatomic,getter=isExclusiveTouch) BOOL exclusiveTouch </p>
<pre><code>// “专一触摸”，默认NO，设置为YES时，对应的View在一个时间点不会和其他的View同时响应，保证了多点触碰同时响应时的数据、逻辑安全。
</code></pre></li>
<li><p>@property(nonatomic) CGAffineTransform transform</p>
<pre><code>// 描述视图的“仿射变换”，通过这个属性隐式改变视图的大小、旋转、位移、矩阵变形。
</code></pre><p>  <a href="http://www.jianshu.com/p/32ac4d71cac7" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p>@property(nonatomic) CGFloat contentScaleFactor</p>
<pre><code>// “内容缩放因子”，其决定了视图的内容是怎样从点坐标系映射到设备的像素坐标系。例如,如果比例因子是2.0和视图frame尺寸是50 x 50,位图用于呈现内容的大小是100 x 100像素。一般情况下，不需要修改这个属性的价值。然而,如果应用程序将使用OpenGL ES,可能想要改变比例因子提升图像质量和渲染性能。
</code></pre></li>
<li><p>@property (nonatomic) UIEdgeInsets layoutMargins</p>
<pre><code>// 在iOS 8中，可以使用layoutMargins去定义view之间的间距,该属性只对AutoLayout布局生效。
</code></pre></li>
<li><p>@property (nonatomic) BOOL clearsContextBeforeDrawing</p>
<pre><code>// 决定是否在绘制（-drawRect:）前清除原上下文内容。
</code></pre></li>
<li><p>@property(nonatomic, strong) UIView *maskView</p>
<pre><code>// 视图的掩饰层视图（蒙版）。iOS 8可用，该视图的alpha决定了又多少视图的内容和背景可以展示。完全或不完全的不透明像素允许底层内容展示，但完全不透明将遮挡内容。（没有使用过系统蒙层，等完全抛弃iOS7后可以试一试。）
</code></pre></li>
<li><p>@property(nonatomic, strong) UIColor *tintColor</p>
<pre><code>// 在iOS7中，UIView新增了一个属性tintColor. 这是一个UIColor，被使用在UIView中改变应用程序的外观的。默认tintColor的值为nil，这表示它将会运用父视图层次的颜色来进行着色。部分诸如UILabel这样的控件不受tintColor控制，而子控件如果设置tintColor，则子控件的子控件的tintColor由最近的父控件传导，这样tintColor传导链就断开了。
// 如果要给自定义控件着色且使用tintColor链条，apple提供了对应回调，需要手动在自定义控件中实现`-(void)tintColorDidChange`，并写对应的设置颜色代码。
// 此外，tintColor支持改变图片颜色。
</code></pre><p>  <a href="http://www.cnblogs.com/wfwenchao/p/4884833.html" target="_blank" rel="external">链接</a></p>
</li>
<li><p>@property(nonatomic) UIViewTintAdjustmentMode tintAdjustmentMode</p>
<pre><code>// 当这个属性的值是UIViewTintAdjustmentModeDimmed,tintColor属性的值被修改提供一个黯淡的外观。(又是一个类似实现蒙版的属性)
// 当这个属性值改变时(通过视图的对应值变化或改变它的父视图的一个值),系统调用-tintColorDidChange方法允许自定义渲染。
</code></pre></li>
<li><p>@property(readonly,strong) UIView *viewForFirstBaselineLayout NS_AVAILABLE_IOS(9_0)</p>
<pre><code>// 对于多行文本视图,第一个基线是最上面一行字的视图基准。（待测试）
// 当你给视图的做NSLayoutAttributeFirstBaseline属性约束,Auto Layout使用此视图的基线作为方法返回。如果这一视图没有基线约束,Auto Layout使用视图的顶层边缘返回。
</code></pre></li>
<li><p>约束属性，类似mansory。解决了诸如不同方向上约束编译不报错但约束失败的问题，做了约束泛型处理。</p>
<pre><code>@property(readonly, strong) NSLayoutXAxisAnchor *leadingAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *trailingAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *leftAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *rightAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *topAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *bottomAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutDimension *widthAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutDimension *heightAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *centerXAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *centerYAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *firstBaselineAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *lastBaselineAnchor NS_AVAILABLE_IOS(9_0);

示例代码：
    //以下代码编译不通过。
    NSLayoutConstraint *constraint =  [view1.leadingAnchor constraintEqualToAnchor:view2.topAnchor];
</code></pre></li>
<li><p>@property (nullable, nonatomic, copy) NSString *restorationIdentifier NS_AVAILABLE_IOS(6_0);</p>
<pre><code>// 这个属性指出是否视图状态信息应该被保存；它也用来在恢复状态的过程中辨识视图。它的值默认nil，默认视图状态不被保存。一旦它被设置，对应的拥有的ViewController便知晓需要保存视图相关信息。
// 这个属性只有在自定义控件中且实现了-encodeRestorableStateWithCoder:和- decodeRestorableStateWithCoder:方法来保存和解析视图信息。
</code></pre></li>
</ul>
<h3 id="4-2-不常用API介绍"><a href="#4-2-不常用API介绍" class="headerlink" title="4.2 不常用API介绍"></a>4.2 不常用API介绍</h3><ul>
<li><p>-(BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</p>
<pre><code>/**
 *  判断一个点是否在该响应接收者（View）内
 *
 *  @param point 点坐标
 *  @param event 通过什么事件进行传导
 *
 *  @return 是就YES
 */
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;
</code></pre></li>
<li><p>-(nullable UIView <em>)hitTest:(CGPoint)point withEvent:(nullable UIEvent </em>)event;</p>
<pre><code>/**
 *  递归调用-pointInside:withEvent:，找到子类中最后一个包含这个点的且响应事件的子类对象。
 *
 *  @param point 点坐标
 *  @param event 事件
 *
 *  @return 对应的对象
 */
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;
</code></pre></li>
<li><p>-(CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;</p>
<pre><code>/**
 *  将一个点的坐标从当前View转换到目标View
 *
 *  @param point 当前View的点
 *  @param view  目标View
 *
 *  @return 目标View上转换后的坐标
 */
- (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;

类似的API还有：
- (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;
- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;
- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;
</code></pre></li>
<li><p>-(CGSize)sizeThatFits:(CGSize)size;</p>
<pre><code>/**
 *  根据传入尺寸和当前View尺寸给出合适尺寸。
 *
 *  @param size
 *
 *  @return 返回系统认为合适的尺寸
 */
- (CGSize)sizeThatFits:(CGSize)size;

这个API可以使用诸如在UIView子类UILabel里面，计算出文字所需要的尺寸；在UIImageView里面计算image的大小；或者是UIView内部的其他元素所占边界。
</code></pre></li>
<li><p>-(void)sizeToFit; </p>
<pre><code>/**
 *  调用-sizeThatFits:，并把对应尺寸赋给UIView
 */
- (void)sizeToFit;
</code></pre></li>
<li><p>-(void)didAddSubview:(UIView *)subview</p>
<pre><code>/**
 *  在子视图被添加的时候调用，默认没有实现。
 *
 *  @param subview 子视图
 */
- (void)didAddSubview:(UIView *)subview;

类似的API有：

// 将要移除子视图调用
- (void)willRemoveSubview:(UIView *)subview;

// 调用者将要被加到父视图时调用
- (void)willMoveToSuperview:(nullable UIView *)newSuperview;

// 恰好被加到父视图时调用
- (void)didMoveToSuperview;

// 与当前所在window对象改变相关 
- (void)willMoveToWindow:(nullable UIWindow *)newWindow;
- (void)didMoveToWindow;
</code></pre></li>
<li><p>-(BOOL)isDescendantOfView:(UIView *)view;</p>
<pre><code>/**
 *  判断当前view是否传入View的子视图
  *
  *  @param view 判断的父视图
  *
  *  @return 是否是传入视图的子视图
  */
 -(BOOL)isDescendantOfView:(UIView *)view;
</code></pre></li>
<li><p>-(void)setNeedsLayout;</p>
<pre><code>/**
 *  当想调整视图的子视图的布局在应用程序的主线程调用这个方法。这个方法会做一个标记并立刻返回。因为这个方法不强行立即更新,而是等待下一个更新周期,可以失效之前多个视图的布局并进行视图更新。这种方式加固了新布局更新在更新周期。
 *  简言之，失效当前布局并标记，在下一个布局周期更新布局。
 */
- (void)setNeedsLayout;
</code></pre></li>
<li><p>-(void)layoutIfNeeded;</p>
<pre><code>/**
 *  以当前视图为根视图，立即更新子视图布局
*/
- (void)layoutIfNeeded;
</code></pre></li>
<li><p>-(void)layoutSubviews;</p>
<pre><code>/**
 *  子类可以重写此方法,以进行更精确的子视图的布局。
 *  只有在autoresizing和基于约束布局的子视图不能提供想要的行为时，应该重写此方法。
 *  你不应该直接调用这个方法。如果你想强行更新布局，就调用setNeedsLayout方法，在下一个布局周期进行。如果你想立即更新视图的布局,调用layoutIfNeeded方法。 
 */
- (void)layoutSubviews;
</code></pre></li>
<li><p>-(UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates;</p>
<pre><code>/**
 *  为当前视图创建一个快照（截图）
 *
 *  @param afterUpdates 表示是否在所有效果应用在视图上了以后再获取快照
 *
 *  @return 快照
 */
- (UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates;

类似API有：
- (UIView *)resizableSnapshotViewFromRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates withCapInsets:(UIEdgeInsets)capInsets;
- (BOOL)drawViewHierarchyInRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates;
</code></pre></li>
<li><p>-(void)exerciseAmbiguityInLayout;</p>
<pre><code>/**
 *  随机改变布局，一般用于基于约束的视图调试。
 */
- (void)exerciseAmbiguityInLayout;
</code></pre></li>
<li><p>-(void)drawRect:(CGRect)rect;</p>
<pre><code>/**
 *  执行重绘操作的回调。这个方法会在一个view第一次出现或当有一个事件触发使当前可见部分失效时触发。不应该主动直接调用它。如果要重新绘制，则调用setNeedsDisplay或setNeedsDisplayInRect:方法，这两个方法会异步在合适的时机回调该方法。
 *
 *  @param rect UIView自己的frame
 */
- (void)drawRect:(CGRect)rect;
</code></pre></li>
<li><p>-(void)setNeedsDisplay;</p>
<pre><code>/**
 *  标记UIView为需要重绘，在下一个绘制循环调用对应绘制方法。
 *  可以使用此方法或setNeedsDisplayInRect:通知系统视图的内容需要重绘。这是一个异步方法。
 *  如果你的view是基于CAEAGLLayer对象，这个方法将不会有作用，它只适用于native drawing technologies（原生绘制）。 
 */
- (void)setNeedsDisplay;

类似方法：
- (void)setNeedsDisplayInRect:(CGRect)invalidRect;
</code></pre></li>
<li><p>-(BOOL)canBecomeFocused;</p>
<pre><code>/**
 *  [可以看看这个，我不会描述。](http://stackoverflow.com/questions/32753109/how-do-you-set-canbecomefocused-for-a-custom-view)
 *
 *  @return 是否View可以被重点突出。
 */
- (BOOL)canBecomeFocused; 
</code></pre></li>
<li><p>还有很多关于布局的不常用方法，这里暂不介绍，有兴趣可以去看<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html" target="_blank" rel="external">文档</a>。</p>
</li>
</ul>
<h2 id="5-绘图进阶"><a href="#5-绘图进阶" class="headerlink" title="5. 绘图进阶"></a>5. 绘图进阶</h2><h3 id="5-1-位图上下文"><a href="#5-1-位图上下文" class="headerlink" title="5.1 位图上下文"></a>5.1 位图上下文</h3><ul>
<li><p>前文谈到了在图形上下文的绘制。除了图形上下文，Quartz 2D还提供了其他上下文给其他设备和场景。这里说说在iOS上使用比较多的位图上下文。位图上下文在UIKit的载体就是熟悉的UIImage了。</p>
</li>
<li><p>简单来说，位图上下文提供了画板让我们可以以图片（bitmap）形式渲染图形。</p>
</li>
<li><p>接下来，来看看位图上下文的基本使用，以及下文会以一个例子来结婚图形上下文和位图上下文的使用。</p>
</li>
<li><p>1.取到需要被操作的图片：</p>
<pre><code>UIImage *image = [UIImage imageNamed:@&quot;mogu&quot;];
</code></pre></li>
<li><p>2.开启一个位图上下文，注意位图上下文跟view的渲染无关联，所以不需要在drawRect.</p>
<pre><code>// size:     位图上下文的尺寸（新图片的尺寸）
// opaque:   不透明度 YES：不透明 NO:透明.通常使用透明的上下文
// scale:    通常不需要缩放上下文，取值为0，表示不缩放
UIGraphicsBeginImageContextWithOptions(image.size, NO, 0);
</code></pre></li>
<li><p>3.描述上下文</p>
<pre><code>  // 画背景,描述上下文的渲染范围。
[image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)];

// 画文字。注意：下面设置的字体和位置是基于图片大小。在demo中的图尺寸是736*618，我们将按20号字体画文字在上下文，但是下文我们将image赋给的UIImageView的尺寸是300*300，所以渲染的image将会被缩放，文字此时已经被渲染在image上，作为图片的一部分，字体也会一起缩放。
NSString *string = @&quot;mogujie.com&quot;;
[string drawAtPoint:CGPointMake(20, 20) withAttributes:@{NSFontAttributeName:[UIFont systemFontOfSize:20],NSForegroundColorAttributeName:[UIColor blackColor]}];

// 从上下文中获取图片
imageView.image = UIGraphicsGetImageFromCurrentImageContext();

// 关闭上下文
UIGraphicsEndImageContext();
</code></pre></li>
</ul>
<h3 id="5-2-案例：截屏功能"><a href="#5-2-案例：截屏功能" class="headerlink" title="5.2 案例：截屏功能"></a>5.2 案例：截屏功能</h3><ul>
<li><p>demo中<code>ScreenshotViewController.m</code>描述了一种截屏功能的实现。</p>
</li>
<li><p>以下说明核心代码：</p>
</li>
</ul>
<ul>
<li><p>1.开启位图上下文</p>
<pre><code>UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, NO, 0);
</code></pre></li>
<li><p>2.根据手势截取矩形</p>
<pre><code>UIBezierPath *path = [UIBezierPath bezierPathWithRect:self.clipView.frame];
// 截取上下文中路径所框部分（有点像clipToBounds，提前划出了能给被显示范围）。
[path addClip];
</code></pre></li>
<li><p>3.获取上下文</p>
<pre><code>CGContextRef ctx = UIGraphicsGetCurrentContext();
</code></pre></li>
<li><p>4.渲染图层到当前已被裁剪的上下文</p>
<pre><code>  // 将当前控制器上图视图的图层渲染到位图上下文中。注意：这一步相当于将图层的元素整合成图片贴到上下文作为裁剪素材，被clipToBounds。
[_imageView.layer renderInContext:ctx];
</code></pre></li>
<li><p>5.从上下文中得到位图</p>
<pre><code>UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
</code></pre></li>
<li><p>6.关闭上下文</p>
<pre><code>UIGraphicsEndImageContext();

_imageView.image = image;
</code></pre></li>
<li><p>7.截取板移除</p>
<pre><code>[self.clipView removeFromSuperview];
</code></pre></li>
</ul>
<h3 id="5-3-案例：涂鸦板"><a href="#5-3-案例：涂鸦板" class="headerlink" title="5.3 案例：涂鸦板"></a>5.3 案例：涂鸦板</h3><ul>
<li><p>继续介绍下一个案例来加强我们对Quartz 2D绘图过程的理解。</p>
</li>
<li><p>要实现一个涂鸦板（类似“你画我猜”），核心功能就是渲染我们手指绘画的路径，次要功能是定制我们绘制的样式。</p>
</li>
<li><p>详细见Demo（DarwingBoardViewController.m 及相关类）。</p>
</li>
</ul>
<h2 id="6-上下文栈"><a href="#6-上下文栈" class="headerlink" title="6. 上下文栈"></a>6. 上下文栈</h2><h3 id="暂时不写，这块内容的价值待发掘。"><a href="#暂时不写，这块内容的价值待发掘。" class="headerlink" title="暂时不写，这块内容的价值待发掘。"></a>暂时不写，这块内容的价值待发掘。</h3><h2 id="7-矩阵变换"><a href="#7-矩阵变换" class="headerlink" title="7. 矩阵变换"></a>7. 矩阵变换</h2><h3 id="7-1-核心API"><a href="#7-1-核心API" class="headerlink" title="7.1 核心API"></a>7.1 核心API</h3><ul>
<li><p>// 位移变换，用于位移上下文。</p>
<ul>
<li>CGContextRef c 上下文</li>
<li>CGFloat tx 横坐标位移</li>
<li>CGFloat ty 纵坐标位移</li>
</ul>
<p><code>void CGContextTranslateCTM ( CGContextRef c, CGFloat tx, CGFloat ty );</code></p>
</li>
<li><p>// 缩放变换，用于缩放上下文。</p>
<ul>
<li>CGContextRef c 上下文</li>
<li>CGFloat sx 横坐标方向缩放因子（保持原样是1.0）</li>
<li>CGFloat sy 纵坐标方向缩放因子</li>
</ul>
<p><code>void CGContextScaleCTM ( CGContextRef c, CGFloat sx, CGFloat sy );</code></p>
</li>
<li><p>// 缩放变换，用于缩放上下文。</p>
<ul>
<li>CGContextRef c 上下文</li>
<li>CGFloat angel 选择角度（顺时针为正）</li>
</ul>
<p><code>void CGContextRotateCTM ( CGContextRef c, CGFloat angle );</code></p>
</li>
</ul>
<h3 id="7-2-示例"><a href="#7-2-示例" class="headerlink" title="7.2 示例"></a>7.2 示例</h3><ul>
<li><p>以下代码1和效果图1：</p>
<pre><code>CGContextTranslateCTM (myContext, w/4, 0);
   CGContextScaleCTM (myContext, .25,  .5);
   CGContextRotateCTM (myContext, radians ( 22.));
</code></pre></li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图7.1.png?raw=true" alt="图7.1"></p>
<ul>
<li><p>以下代码2和效果图2：</p>
<pre><code>CGContextRotateCTM (myContext, radians ( 22.));
   CGContextScaleCTM (myContext, .25,  .5);
   CGContextTranslateCTM (myContext, w/4, 0);
</code></pre></li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图7.2.png?raw=true" alt="图7.2"></p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ol>
<li><a href="http://www.jianshu.com/p/0e785269dccc" target="_blank" rel="external">《Quartz2D》 by Ljson</a></li>
<li><a href="http://www.cnblogs.com/hxwj/p/5217611.html" target="_blank" rel="external">《UIView》 by 幻想无极</a></li>
<li><a href="developer.apple.com/library/etc/redirect/xcode/ios/1151/documentation/UIKit/Reference/UIView_Class/index.html">UIView文档</a></li>
<li><a href="developer.apple.com/library/etc/redirect/xcode/ios/1151/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_overview/dq_overview.html">Quartz 2D文档</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/14/Allocations使用简介/" rel="next" title="Allocations使用简介">
                <i class="fa fa-chevron-left"></i> Allocations使用简介
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="王维恒" />
          <p class="site-author-name" itemprop="name">王维恒</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#目录"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Demo-链接"><span class="nav-number">2.</span> <span class="nav-text">Demo 链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-什么的Quartz2D？"><span class="nav-number">3.</span> <span class="nav-text">1.什么的Quartz2D？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-官方文档概念："><span class="nav-number">3.1.</span> <span class="nav-text">1.1 官方文档概念：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-几个重要概念"><span class="nav-number">3.2.</span> <span class="nav-text">1.2 几个重要概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-使用姿势"><span class="nav-number">4.</span> <span class="nav-text">2.使用姿势</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-使用最原生API（比较繁琐）"><span class="nav-number">4.1.</span> <span class="nav-text">2.1 使用最原生API（比较繁琐）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-使用UIKit封装的API"><span class="nav-number">4.2.</span> <span class="nav-text">2.2 使用UIKit封装的API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-基本绘图案例"><span class="nav-number">5.</span> <span class="nav-text">3.基本绘图案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-进度圈绘制"><span class="nav-number">5.1.</span> <span class="nav-text">3.1 进度圈绘制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-饼状图"><span class="nav-number">5.2.</span> <span class="nav-text">3.2 饼状图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-柱状图"><span class="nav-number">5.3.</span> <span class="nav-text">3.3 柱状图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-UIView的生命周期"><span class="nav-number">6.</span> <span class="nav-text">4.UIView的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-不常用属性介绍"><span class="nav-number">6.1.</span> <span class="nav-text">4.1 不常用属性介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-不常用API介绍"><span class="nav-number">6.2.</span> <span class="nav-text">4.2 不常用API介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-绘图进阶"><span class="nav-number">7.</span> <span class="nav-text">5. 绘图进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-位图上下文"><span class="nav-number">7.1.</span> <span class="nav-text">5.1 位图上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-案例：截屏功能"><span class="nav-number">7.2.</span> <span class="nav-text">5.2 案例：截屏功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-案例：涂鸦板"><span class="nav-number">7.3.</span> <span class="nav-text">5.3 案例：涂鸦板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-上下文栈"><span class="nav-number">8.</span> <span class="nav-text">6. 上下文栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#暂时不写，这块内容的价值待发掘。"><span class="nav-number">8.1.</span> <span class="nav-text">暂时不写，这块内容的价值待发掘。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-矩阵变换"><span class="nav-number">9.</span> <span class="nav-text">7. 矩阵变换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-核心API"><span class="nav-number">9.1.</span> <span class="nav-text">7.1 核心API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-示例"><span class="nav-number">9.2.</span> <span class="nav-text">7.2 示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考链接："><span class="nav-number">10.</span> <span class="nav-text">参考链接：</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王维恒</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
