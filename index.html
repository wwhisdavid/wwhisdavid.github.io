<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="果然是我">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="果然是我">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="果然是我">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 果然是我 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">果然是我</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">记录生活。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/24/Quartz 2D学习笔记/" itemprop="url">
                  Quartz 2D学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-24T19:49:15+08:00" content="2016-07-24">
              2016-07-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>去年的时候学习了一发Quartz Core，然而除了写几个demo也没有用上。现在想想都忘得差不多了，最近要开始写写博客记录自己的知识体系，就从捡起Quartz2D开始吧。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>什么的Quartz 2D？</li>
<li>使用姿势。</li>
<li>基本绘图案例。</li>
<li>UIView。</li>
<li>绘图进阶。</li>
<li>上下文栈（暂时不写）。</li>
<li>矩阵变换。</li>
</ul>
<h2 id="Demo-链接"><a href="#Demo-链接" class="headerlink" title="Demo 链接"></a><a href="https://github.com/wwhisdavid/Quartz2DDemo" target="_blank" rel="external">Demo 链接</a></h2><h2 id="1-什么的Quartz2D？"><a href="#1-什么的Quartz2D？" class="headerlink" title="1.什么的Quartz2D？"></a>1.什么的Quartz2D？</h2><h3 id="1-1-官方文档概念："><a href="#1-1-官方文档概念：" class="headerlink" title="1.1 官方文档概念："></a>1.1 官方文档概念：</h3><ul>
<li>Quartz 2D是一个支持iOS和MacOS的二维绘图引擎（C语音API）。</li>
<li>Quartz 2D在效率上可以充分地利用图像硬件。</li>
<li>我们可以使用其进行基于路径的绘制、可变透明度绘制、遮影绘制、平滑渲染、色彩管理等。</li>
<li>在iOS系统，Quartz 2D和所有图像渲染相关的技术一起发挥着作用。</li>
</ul>
<h3 id="1-2-几个重要概念"><a href="#1-2-几个重要概念" class="headerlink" title="1.2 几个重要概念"></a>1.2 几个重要概念</h3><ul>
<li>The Page –&gt; 页面(画布)</li>
</ul>
<pre><code>Quartz 2D使用画家的成像模型。在画家的模型中,每个连续的绘图操作一层“油漆”输出到“画布”,通常被称为一个页面。可以修改页面上的油漆覆盖更多的油漆通过额外的绘图操作。一个对象在页面上绘制不能，修改非通过覆盖更多的油漆。这个模型提供强大的原语允许构建非常复杂的图像从小画起。


简单的说，Quartz 2D的绘画模型是对实际绘画的抽象。通过不断往画板上绘制、覆盖来达到需要的结果。所以 ，绘制的顺序非常重要。而画布有可能是任何载体。


下图描述了这一模型，我们可见，绘图顺序影响了最终的结果。
![图1.1](https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图1.1.png?raw=true)
</code></pre><ul>
<li><p>Drawing Destinations: The Graphics Context –&gt; 画布的抽象：图形上下文</p>
<p>  图形上下文(CGContextRef)是一个不透明的数据类型(下文介绍这个概念)，其封装了Quartz 2D使用来画图像到输出设备的信息。在一个图形上下文的信息包括图形的绘图参数和于特定设备的表示页面上的元素。所有Quartz 2D涉及对象在上下文中。我们可以理解为他是你绘制的图像的数据、步骤的存放地，类似一种组件的概念，让程序员不需要考虑设备的兼容性，体现了一种封装的思想。</p>
</li>
</ul>
<pre><code>从下图可以看出，绘画元素封装在上下文中，供不同设备取用。    
![图1.2](https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图1.2.png?raw=true)
</code></pre><ul>
<li><p>Quartz 2D Opaque Data Types –&gt; 不透明数据类型</p>
<p>  所谓Opaque，即不透明的意思。个人认为表达了是一种封装的意思，即不为外部可见。Quartz 2D中的各种上下文都被称为不透明的。不透明数据类型指代的是那些上下文元数据类型，包括CGPathRef(路径)、CGImageRef(图片)、CGShadingRef(遮影)等，是绘图的元数据引用，可以看做绘图最基本的上下文元素。</p>
</li>
</ul>
<pre><code>下图为不透明数据类型的演示，即各种类型图案都是由不透明数据类型作为元数据构成。
![图1.3](https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图1.3.png?raw=true)
</code></pre><ul>
<li><p>Graphics States –&gt; 图形状态</p>
<p>  Quartz根据当前图形状态参数修改绘图操作的结果。简单来说，图形状态就是图形参数，状态决定了渲染结果。可以将其看做是图形上下文的某一时刻属性的集合。</p>
<p>  图形的图形上下文包含堆栈状态。当Quartz创建一个图形上下文,此时栈是空的。当你保存图形状态时, Quartz将当前图形状态的副本压入堆栈。当你恢复图形状态时, Quartz弹出图形状态堆栈的顶部。出现状态成为当前图形状态。</p>
<p>  要保存当前的图形状态,使用函数<code>CGContextSaveGState</code>来push当前图形状态的副本入堆栈。恢复先前保存的图形状态,使用功能<code>CGContextRestoreGState</code>替换当前的图形状态的图形状态堆栈的顶部。</p>
<p>  <code>注意,并不是当前的绘图环境的所有方面是图形的元素状态。</code>详细被作为状态的参数见下表。</p>
<p>  Params  | 。。。<br>  ————- | ————-<br>  Current transformation matrix (CTM)  | Content Cell<br>  Clipping area  | Content Cell<br>  Line: width, join, cap, dash, miter limit  | Content Cell<br>  Accuracy of curve estimation (flatness)  | Content Cell<br>  Anti-aliasing setting  | Content Cell<br>  Color: fill and stroke settings  | Content Cell<br>  Alpha value (transparency)  | Content Cell<br>  Rendering intent  | Content Cell<br>  Color space: fill and stroke settings  | Content Cell<br>  Text: font, font size, character spacing, text drawing mode  | Content Cell<br>  Blend mode  | Content Cell</p>
</li>
<li><p>Quartz 2D Coordinate Systems –&gt; 坐标系</p>
<p>  Quartz 2D的坐标系就是平常的几何坐标。坐标系的确定需要做到与设备无关，否则不同设备的像素要求可能会使图像失真。Quartz 2D在处理不同坐标体系和不同设备兼容时，使用了矩阵变换。</p>
<p>  下图为Quartz 2D中的坐标系。<br>  <img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图1.4.png?raw=true" alt="图1.4"></p>
<p>  需要注意，UIView使用的坐标系与Quartz不同，其以左上角为原点。</p>
</li>
</ul>
<ul>
<li><p>Memory Management: Object Ownership –&gt; 内存管理</p>
<p>  Quartz使用的是Core Foundation的内存管理模型，需要手动释放引用计数（ARC失效）。</p>
<p>  注意：如果你调用的函数有<code>copy</code>或<code>create</code>字眼，就表示你持有了该对象，需要手动去释放，对应的持有函数有CGColorSpaceRetain、CFRetain和释放函数CGColorSpaceRelease、 CFRelease。</p>
</li>
</ul>
<h2 id="2-使用姿势"><a href="#2-使用姿势" class="headerlink" title="2.使用姿势"></a>2.使用姿势</h2><p><strong>写在前面</strong>：所以Quartz 2D的API均要在UIView的<code>-(void)drawRect:(CGRect)rect;</code>方法中调用。这是因为Quartz中使用的上下文只能在该方法获取到，这是与UIView的生命周期相关，这个方法作为生命周期的回调来处理渲染。</p>
<h3 id="2-1-使用最原生API（比较繁琐）"><a href="#2-1-使用最原生API（比较繁琐）" class="headerlink" title="2.1 使用最原生API（比较繁琐）"></a>2.1 使用最原生API（比较繁琐）</h3><ul>
<li><p>从画一条线管中窥豹</p>
<pre><code>- (void)drawSimleLine{
    // 1.获取上下文（画作的封装）
    CGContextRef ctx = UIGraphicsGetCurrentContext();

    // 2.描述绘制线条
    CGMutablePathRef path = CGPathCreateMutable();

    // 3.设置起点 --&gt; 终点 --&gt; 渲染

    // 起点（30，30）
    CGPathMoveToPoint(path, NULL, 10, 50);

    // 添加一根线到某个终点（100，100）
    CGPathAddLineToPoint(path, NULL, 100, 100);

    // 4.把路径添加到上下文
    CGContextAddPath(ctx, path);

    // 5.渲染上下文
    CGContextStrokePath(ctx);

    // 6.内存释放
    CGPathRelease(path);
}
</code></pre></li>
<li><p>稍微简洁地画一条线</p>
<pre><code>- (void)drawSimleLine2{
    // 1.获取上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();

    // 2.描述路径
    // 设置起点、线、终点
    CGContextMoveToPoint(ctx, 20, 50);

    CGContextAddLineToPoint(ctx, 100, 100);

    // 3.渲染上下文
    CGContextStrokePath(ctx);
}
</code></pre></li>
<li><p>从上面的两条线，我们可以归纳出Quartz 2D画图的步骤：</p>
<pre><code>1.开启上下文 --&gt; 2.画图（点、线） --&gt; 3.渲染 --&gt; 4.内存释放
</code></pre></li>
<li><p>第一章中我们提到了上下文有一个重要特性：状态，我们可以理解为就某一时点上下文图像的熟悉。在<code>渲染上下文之前</code>我们可以通过设置状态改变最终渲染的样式：</p>
<pre><code>// 颜色
[[UIColor redColor] setStroke];

// 线宽
CGContextSetLineWidth(ctx, 5);

// 设置连接样式
CGContextSetLineJoin(ctx, kCGLineJoinBevel);

// 设置顶角样式
CGContextSetLineCap(ctx, kCGLineCapRound);
</code></pre></li>
<li><p>对于复杂的图像，光靠点和直线肯定是不够的，Quartz 2D支持通过控制点来绘制任意曲线：</p>
<pre><code>@param c   上下文
@param cpx 控制点x
@param cpy 控制点y
@param x   终点x
@param y   终点y
void CGContextAddQuadCurveToPoint(CGContextRef __nullable c,CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y);

关于控制点，可以见下图。
</code></pre></li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图2.1.png?raw=true" alt="图2.1"></p>
<h3 id="2-2-使用UIKit封装的API"><a href="#2-2-使用UIKit封装的API" class="headerlink" title="2.2 使用UIKit封装的API"></a>2.2 使用UIKit封装的API</h3><ul>
<li><p>Apple考虑到Quartz 2D使用的繁琐，和内存管理的问题。使用了<code>UIBezierPath</code>对Quartz 2D进行了封装，API十分面向对象。同样是画一条线：</p>
<pre><code>// 1.创建路径
UIBezierPath *path = [UIBezierPath bezierPath];

// 2.设置起点
[path moveToPoint:CGPointMake(30, 50)];

// 添加一根线到某个点
[path addLineToPoint:CGPointMake(100, 100)];
// 颜色
[[UIColor greenColor] set];
// 线宽
path.lineWidth = 10;

// 3.绘制路径
[path stroke];
</code></pre></li>
<li><p>画一些基本图形：</p>
<pre><code>// 1. 扇形
// 半径
CGFloat radius = rect.size.width * 0.5;
// 圆心
CGPoint center = CGPointMake(radius, radius);
// 圆弧终点角度
CGFloat endA = M_PI_2;
// 设置圆弧路径（其中clockwise:YES表示顺时针渲染）
UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius - 2 startAngle:- M_PI_2 endAngle:endA clockwise:YES];
// 从弧线上拉直线到圆心
[path addLineToPoint:center];
// 闭合扇形
[path closePath];
// 以填充方式渲染
[path fill];

// 2. 圆角矩形
// cornerRadius表示圆角半径
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 10, 100, 100) cornerRadius:30];
[path stroke];
</code></pre></li>
<li><p>当然，同样可以画复杂曲线（有两个极点）：</p>
</li>
</ul>
<pre><code>UIBezierPath *path = [UIBezierPath bezierPath];
// 设定起点
[path moveToPoint:CGPointMake(0,0)];
// 添加两个控制点
[path addCurveToPoint:CGPointMake(100, 100)
     controlPoint1:CGPointMake(50, 0)   
     controlPoint2:CGPointMake(0, 50)];            
// 添加终点
[path addLineToPoint:CGPointMake(0, 100)];
// 闭合
[path closePath];

大概结果见下图。
</code></pre><p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图2.2.png?raw=true" alt="图2.2"></p>
<h2 id="3-基本绘图案例"><a href="#3-基本绘图案例" class="headerlink" title="3.基本绘图案例"></a>3.基本绘图案例</h2><h3 id="3-1-进度圈绘制"><a href="#3-1-进度圈绘制" class="headerlink" title="3.1 进度圈绘制"></a>3.1 进度圈绘制</h3><ul>
<li><p>这里举一个使用UIBezierPath绘制一个类似ProgressHUB的进度圈。这里的思路来自于上文绘制圆弧，在<code>0°--&gt; 360°</code>范围内通过调用UIView的重绘回调（关于UIView的各种绘制时机，下一章介绍），不断在圆心向圆弧画线，且以fill方式渲染。具体代码如下：</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    CGFloat radius = rect.size.width * 0.5;
    CGPoint center = CGPointMake(radius, radius);
    // 此处的_progress是一个CGFloat变量（0，1），控制当前的进度
    CGFloat endA = - M_PI_2 + _progress * M_PI * 2;

    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius - 2 startAngle:-M_PI_2 endAngle:endA clockwise:YES];
    [path addLineToPoint:center];
    [path closePath];
    [path fill];
}

// 上述代码仅仅描述了一次扇形的微分绘制，外部通过设置_progress属性来重绘，代码如下：
- (void)setProgress:(CGFloat)progress
{
    _progress = progress;
    // 系统重绘
    [self setNeedsDisplay];
}
</code></pre></li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图3.1.png?raw=true" alt="图3.1"></p>
<h3 id="3-2-饼状图"><a href="#3-2-饼状图" class="headerlink" title="3.2 饼状图"></a>3.2 饼状图</h3><ul>
<li><p>本节说明如何使用UIBezierPath绘制饼状图。绘制饼状图的思路与绘制进度圈的思路基本一致，根据数据比值在360°范围内绘制各自扇形形成饼状图。代码如下：</p>
<pre><code>- (void)drawRect:(CGRect)rect{
    // 设置饼状数据，分别占10%、20%、70%
    NSArray *arr = [NSArray arrayWithObjects:@10, @20, @70, nil];
    CGFloat radius = rect.size.width * 0.5;
    CGPoint center = CGPointMake(radius, radius);

    __block CGFloat startA = 0;
    __block CGFloat angle = 0;
    __block CGFloat endA = 0;
    // 依次画数组中的扇形
    for (int i = 0; i &lt; arr.count; i++) {
        startA = endA;
        angle = [arr[i] integerValue] / 100.0 * M_PI * 2;
        endA = startA + angle;

        UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];

        [path addLineToPoint:center];
        // 设置颜色这里选择设置随机颜色，代码就不贴了。
        [[self colorRandom] set];
        [path fill];
    }
}
</code></pre></li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图3.2.png?raw=true" alt="图3.2"></p>
<h3 id="3-3-柱状图"><a href="#3-3-柱状图" class="headerlink" title="3.3 柱状图"></a>3.3 柱状图</h3><ul>
<li><p>本节说明如何使用UIBezierPath绘制柱状图，通过排布矩形实现：</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    NSArray *arr = @[@10, @20, @30, @15];

    CGFloat x = 0;
    CGFloat y = 0;
    CGFloat w = 0;
    CGFloat h = 0;

    for (int i = 0; i &lt; arr.count; i++) {
        w = rect.size.width / (2 * arr.count - 1);
        x = 2 * w * i;
        h = [arr[i] floatValue] / 100.0 * rect.size.height;
        y = rect.size.height - h;

        UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(x, y, w, h)];

        [[self colorRandom] set];
        [path fill];
</code></pre></li>
</ul>
<pre><code>    }
} 
</code></pre><p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图3.3.png?raw=true" alt="图3.3"></p>
<h2 id="4-UIView的生命周期"><a href="#4-UIView的生命周期" class="headerlink" title="4.UIView的生命周期"></a>4.UIView的生命周期</h2><p>这篇文章抽空来谈谈UIView。UIView是我们UI编程的基础与核心，也是Quartz 2D的渲染载体。</p>
<h3 id="4-1-不常用属性介绍"><a href="#4-1-不常用属性介绍" class="headerlink" title="4.1 不常用属性介绍"></a>4.1 不常用属性介绍</h3><ul>
<li><p>@property(nonatomic,getter=isExclusiveTouch) BOOL exclusiveTouch </p>
<pre><code>// “专一触摸”，默认NO，设置为YES时，对应的View在一个时间点不会和其他的View同时响应，保证了多点触碰同时响应时的数据、逻辑安全。
</code></pre></li>
<li><p>@property(nonatomic) CGAffineTransform transform</p>
<pre><code>// 描述视图的“仿射变换”，通过这个属性隐式改变视图的大小、旋转、位移、矩阵变形。
</code></pre><p>  <a href="http://www.jianshu.com/p/32ac4d71cac7" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p>@property(nonatomic) CGFloat contentScaleFactor</p>
<pre><code>// “内容缩放因子”，其决定了视图的内容是怎样从点坐标系映射到设备的像素坐标系。例如,如果比例因子是2.0和视图frame尺寸是50 x 50,位图用于呈现内容的大小是100 x 100像素。一般情况下，不需要修改这个属性的价值。然而,如果应用程序将使用OpenGL ES,可能想要改变比例因子提升图像质量和渲染性能。
</code></pre></li>
<li><p>@property (nonatomic) UIEdgeInsets layoutMargins</p>
<pre><code>// 在iOS 8中，可以使用layoutMargins去定义view之间的间距,该属性只对AutoLayout布局生效。
</code></pre></li>
<li><p>@property (nonatomic) BOOL clearsContextBeforeDrawing</p>
<pre><code>// 决定是否在绘制（-drawRect:）前清除原上下文内容。
</code></pre></li>
<li><p>@property(nonatomic, strong) UIView *maskView</p>
<pre><code>// 视图的掩饰层视图（蒙版）。iOS 8可用，该视图的alpha决定了又多少视图的内容和背景可以展示。完全或不完全的不透明像素允许底层内容展示，但完全不透明将遮挡内容。（没有使用过系统蒙层，等完全抛弃iOS7后可以试一试。）
</code></pre></li>
<li><p>@property(nonatomic, strong) UIColor *tintColor</p>
<pre><code>// 在iOS7中，UIView新增了一个属性tintColor. 这是一个UIColor，被使用在UIView中改变应用程序的外观的。默认tintColor的值为nil，这表示它将会运用父视图层次的颜色来进行着色。部分诸如UILabel这样的控件不受tintColor控制，而子控件如果设置tintColor，则子控件的子控件的tintColor由最近的父控件传导，这样tintColor传导链就断开了。
// 如果要给自定义控件着色且使用tintColor链条，apple提供了对应回调，需要手动在自定义控件中实现`-(void)tintColorDidChange`，并写对应的设置颜色代码。
// 此外，tintColor支持改变图片颜色。
</code></pre><p>  <a href="http://www.cnblogs.com/wfwenchao/p/4884833.html" target="_blank" rel="external">链接</a></p>
</li>
<li><p>@property(nonatomic) UIViewTintAdjustmentMode tintAdjustmentMode</p>
<pre><code>// 当这个属性的值是UIViewTintAdjustmentModeDimmed,tintColor属性的值被修改提供一个黯淡的外观。(又是一个类似实现蒙版的属性)
// 当这个属性值改变时(通过视图的对应值变化或改变它的父视图的一个值),系统调用-tintColorDidChange方法允许自定义渲染。
</code></pre></li>
<li><p>@property(readonly,strong) UIView *viewForFirstBaselineLayout NS_AVAILABLE_IOS(9_0)</p>
<pre><code>// 对于多行文本视图,第一个基线是最上面一行字的视图基准。（待测试）
// 当你给视图的做NSLayoutAttributeFirstBaseline属性约束,Auto Layout使用此视图的基线作为方法返回。如果这一视图没有基线约束,Auto Layout使用视图的顶层边缘返回。
</code></pre></li>
<li><p>约束属性，类似mansory。解决了诸如不同方向上约束编译不报错但约束失败的问题，做了约束泛型处理。</p>
<pre><code>@property(readonly, strong) NSLayoutXAxisAnchor *leadingAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *trailingAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *leftAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *rightAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *topAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *bottomAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutDimension *widthAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutDimension *heightAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *centerXAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *centerYAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *firstBaselineAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *lastBaselineAnchor NS_AVAILABLE_IOS(9_0);

示例代码：
    //以下代码编译不通过。
    NSLayoutConstraint *constraint =  [view1.leadingAnchor constraintEqualToAnchor:view2.topAnchor];
</code></pre></li>
<li><p>@property (nullable, nonatomic, copy) NSString *restorationIdentifier NS_AVAILABLE_IOS(6_0);</p>
<pre><code>// 这个属性指出是否视图状态信息应该被保存；它也用来在恢复状态的过程中辨识视图。它的值默认nil，默认视图状态不被保存。一旦它被设置，对应的拥有的ViewController便知晓需要保存视图相关信息。
// 这个属性只有在自定义控件中且实现了-encodeRestorableStateWithCoder:和- decodeRestorableStateWithCoder:方法来保存和解析视图信息。
</code></pre></li>
</ul>
<h3 id="4-2-不常用API介绍"><a href="#4-2-不常用API介绍" class="headerlink" title="4.2 不常用API介绍"></a>4.2 不常用API介绍</h3><ul>
<li><p>-(BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</p>
<pre><code>/**
 *  判断一个点是否在该响应接收者（View）内
 *
 *  @param point 点坐标
 *  @param event 通过什么事件进行传导
 *
 *  @return 是就YES
 */
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;
</code></pre></li>
<li><p>-(nullable UIView <em>)hitTest:(CGPoint)point withEvent:(nullable UIEvent </em>)event;</p>
<pre><code>/**
 *  递归调用-pointInside:withEvent:，找到子类中最后一个包含这个点的且响应事件的子类对象。
 *
 *  @param point 点坐标
 *  @param event 事件
 *
 *  @return 对应的对象
 */
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;
</code></pre></li>
<li><p>-(CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;</p>
<pre><code>/**
 *  将一个点的坐标从当前View转换到目标View
 *
 *  @param point 当前View的点
 *  @param view  目标View
 *
 *  @return 目标View上转换后的坐标
 */
- (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;

类似的API还有：
- (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;
- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;
- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;
</code></pre></li>
<li><p>-(CGSize)sizeThatFits:(CGSize)size;</p>
<pre><code>/**
 *  根据传入尺寸和当前View尺寸给出合适尺寸。
 *
 *  @param size
 *
 *  @return 返回系统认为合适的尺寸
 */
- (CGSize)sizeThatFits:(CGSize)size;

这个API可以使用诸如在UIView子类UILabel里面，计算出文字所需要的尺寸；在UIImageView里面计算image的大小；或者是UIView内部的其他元素所占边界。
</code></pre></li>
<li><p>-(void)sizeToFit; </p>
<pre><code>/**
 *  调用-sizeThatFits:，并把对应尺寸赋给UIView
 */
- (void)sizeToFit;
</code></pre></li>
<li><p>-(void)didAddSubview:(UIView *)subview</p>
<pre><code>/**
 *  在子视图被添加的时候调用，默认没有实现。
 *
 *  @param subview 子视图
 */
- (void)didAddSubview:(UIView *)subview;

类似的API有：

// 将要移除子视图调用
- (void)willRemoveSubview:(UIView *)subview;

// 调用者将要被加到父视图时调用
- (void)willMoveToSuperview:(nullable UIView *)newSuperview;

// 恰好被加到父视图时调用
- (void)didMoveToSuperview;

// 与当前所在window对象改变相关 
- (void)willMoveToWindow:(nullable UIWindow *)newWindow;
- (void)didMoveToWindow;
</code></pre></li>
<li><p>-(BOOL)isDescendantOfView:(UIView *)view;</p>
<pre><code>/**
 *  判断当前view是否传入View的子视图
  *
  *  @param view 判断的父视图
  *
  *  @return 是否是传入视图的子视图
  */
 -(BOOL)isDescendantOfView:(UIView *)view;
</code></pre></li>
<li><p>-(void)setNeedsLayout;</p>
<pre><code>/**
 *  当想调整视图的子视图的布局在应用程序的主线程调用这个方法。这个方法会做一个标记并立刻返回。因为这个方法不强行立即更新,而是等待下一个更新周期,可以失效之前多个视图的布局并进行视图更新。这种方式加固了新布局更新在更新周期。
 *  简言之，失效当前布局并标记，在下一个布局周期更新布局。
 */
- (void)setNeedsLayout;
</code></pre></li>
<li><p>-(void)layoutIfNeeded;</p>
<pre><code>/**
 *  以当前视图为根视图，立即更新子视图布局
*/
- (void)layoutIfNeeded;
</code></pre></li>
<li><p>-(void)layoutSubviews;</p>
<pre><code>/**
 *  子类可以重写此方法,以进行更精确的子视图的布局。
 *  只有在autoresizing和基于约束布局的子视图不能提供想要的行为时，应该重写此方法。
 *  你不应该直接调用这个方法。如果你想强行更新布局，就调用setNeedsLayout方法，在下一个布局周期进行。如果你想立即更新视图的布局,调用layoutIfNeeded方法。 
 */
- (void)layoutSubviews;
</code></pre></li>
<li><p>-(UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates;</p>
<pre><code>/**
 *  为当前视图创建一个快照（截图）
 *
 *  @param afterUpdates 表示是否在所有效果应用在视图上了以后再获取快照
 *
 *  @return 快照
 */
- (UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates;

类似API有：
- (UIView *)resizableSnapshotViewFromRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates withCapInsets:(UIEdgeInsets)capInsets;
- (BOOL)drawViewHierarchyInRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates;
</code></pre></li>
<li><p>-(void)exerciseAmbiguityInLayout;</p>
<pre><code>/**
 *  随机改变布局，一般用于基于约束的视图调试。
 */
- (void)exerciseAmbiguityInLayout;
</code></pre></li>
<li><p>-(void)drawRect:(CGRect)rect;</p>
<pre><code>/**
 *  执行重绘操作的回调。这个方法会在一个view第一次出现或当有一个事件触发使当前可见部分失效时触发。不应该主动直接调用它。如果要重新绘制，则调用setNeedsDisplay或setNeedsDisplayInRect:方法，这两个方法会异步在合适的时机回调该方法。
 *
 *  @param rect UIView自己的frame
 */
- (void)drawRect:(CGRect)rect;
</code></pre></li>
<li><p>-(void)setNeedsDisplay;</p>
<pre><code>/**
 *  标记UIView为需要重绘，在下一个绘制循环调用对应绘制方法。
 *  可以使用此方法或setNeedsDisplayInRect:通知系统视图的内容需要重绘。这是一个异步方法。
 *  如果你的view是基于CAEAGLLayer对象，这个方法将不会有作用，它只适用于native drawing technologies（原生绘制）。 
 */
- (void)setNeedsDisplay;

类似方法：
- (void)setNeedsDisplayInRect:(CGRect)invalidRect;
</code></pre></li>
<li><p>-(BOOL)canBecomeFocused;</p>
<pre><code>/**
 *  [可以看看这个，我不会描述。](http://stackoverflow.com/questions/32753109/how-do-you-set-canbecomefocused-for-a-custom-view)
 *
 *  @return 是否View可以被重点突出。
 */
- (BOOL)canBecomeFocused; 
</code></pre></li>
<li><p>还有很多关于布局的不常用方法，这里暂不介绍，有兴趣可以去看<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html" target="_blank" rel="external">文档</a>。</p>
</li>
</ul>
<h2 id="5-绘图进阶"><a href="#5-绘图进阶" class="headerlink" title="5. 绘图进阶"></a>5. 绘图进阶</h2><h3 id="5-1-位图上下文"><a href="#5-1-位图上下文" class="headerlink" title="5.1 位图上下文"></a>5.1 位图上下文</h3><ul>
<li><p>前文谈到了在图形上下文的绘制。除了图形上下文，Quartz 2D还提供了其他上下文给其他设备和场景。这里说说在iOS上使用比较多的位图上下文。位图上下文在UIKit的载体就是熟悉的UIImage了。</p>
</li>
<li><p>简单来说，位图上下文提供了画板让我们可以以图片（bitmap）形式渲染图形。</p>
</li>
<li><p>接下来，来看看位图上下文的基本使用，以及下文会以一个例子来结婚图形上下文和位图上下文的使用。</p>
</li>
<li><p>1.取到需要被操作的图片：</p>
<pre><code>UIImage *image = [UIImage imageNamed:@&quot;mogu&quot;];
</code></pre></li>
<li><p>2.开启一个位图上下文，注意位图上下文跟view的渲染无关联，所以不需要在drawRect.</p>
<pre><code>// size:     位图上下文的尺寸（新图片的尺寸）
// opaque:   不透明度 YES：不透明 NO:透明.通常使用透明的上下文
// scale:    通常不需要缩放上下文，取值为0，表示不缩放
UIGraphicsBeginImageContextWithOptions(image.size, NO, 0);
</code></pre></li>
<li><p>3.描述上下文</p>
<pre><code>  // 画背景,描述上下文的渲染范围。
[image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)];

// 画文字。注意：下面设置的字体和位置是基于图片大小。在demo中的图尺寸是736*618，我们将按20号字体画文字在上下文，但是下文我们将image赋给的UIImageView的尺寸是300*300，所以渲染的image将会被缩放，文字此时已经被渲染在image上，作为图片的一部分，字体也会一起缩放。
NSString *string = @&quot;mogujie.com&quot;;
[string drawAtPoint:CGPointMake(20, 20) withAttributes:@{NSFontAttributeName:[UIFont systemFontOfSize:20],NSForegroundColorAttributeName:[UIColor blackColor]}];

// 从上下文中获取图片
imageView.image = UIGraphicsGetImageFromCurrentImageContext();

// 关闭上下文
UIGraphicsEndImageContext();
</code></pre></li>
</ul>
<h3 id="5-2-案例：截屏功能"><a href="#5-2-案例：截屏功能" class="headerlink" title="5.2 案例：截屏功能"></a>5.2 案例：截屏功能</h3><ul>
<li><p>demo中<code>ScreenshotViewController.m</code>描述了一种截屏功能的实现。</p>
</li>
<li><p>以下说明核心代码：</p>
</li>
</ul>
<ul>
<li><p>1.开启位图上下文</p>
<pre><code>UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, NO, 0);
</code></pre></li>
<li><p>2.根据手势截取矩形</p>
<pre><code>UIBezierPath *path = [UIBezierPath bezierPathWithRect:self.clipView.frame];
// 截取上下文中路径所框部分（有点像clipToBounds，提前划出了能给被显示范围）。
[path addClip];
</code></pre></li>
<li><p>3.获取上下文</p>
<pre><code>CGContextRef ctx = UIGraphicsGetCurrentContext();
</code></pre></li>
<li><p>4.渲染图层到当前已被裁剪的上下文</p>
<pre><code>  // 将当前控制器上图视图的图层渲染到位图上下文中。注意：这一步相当于将图层的元素整合成图片贴到上下文作为裁剪素材，被clipToBounds。
[_imageView.layer renderInContext:ctx];
</code></pre></li>
<li><p>5.从上下文中得到位图</p>
<pre><code>UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
</code></pre></li>
<li><p>6.关闭上下文</p>
<pre><code>UIGraphicsEndImageContext();

_imageView.image = image;
</code></pre></li>
<li><p>7.截取板移除</p>
<pre><code>[self.clipView removeFromSuperview];
</code></pre></li>
</ul>
<h3 id="5-3-案例：涂鸦板"><a href="#5-3-案例：涂鸦板" class="headerlink" title="5.3 案例：涂鸦板"></a>5.3 案例：涂鸦板</h3><ul>
<li><p>继续介绍下一个案例来加强我们对Quartz 2D绘图过程的理解。</p>
</li>
<li><p>要实现一个涂鸦板（类似“你画我猜”），核心功能就是渲染我们手指绘画的路径，次要功能是定制我们绘制的样式。</p>
</li>
<li><p>详细见Demo（DarwingBoardViewController.m 及相关类）。</p>
</li>
</ul>
<h2 id="6-上下文栈"><a href="#6-上下文栈" class="headerlink" title="6. 上下文栈"></a>6. 上下文栈</h2><h3 id="暂时不写，这块内容的价值待发掘。"><a href="#暂时不写，这块内容的价值待发掘。" class="headerlink" title="暂时不写，这块内容的价值待发掘。"></a>暂时不写，这块内容的价值待发掘。</h3><h2 id="7-矩阵变换"><a href="#7-矩阵变换" class="headerlink" title="7. 矩阵变换"></a>7. 矩阵变换</h2><h3 id="7-1-核心API"><a href="#7-1-核心API" class="headerlink" title="7.1 核心API"></a>7.1 核心API</h3><ul>
<li><p>// 位移变换，用于位移上下文。</p>
<ul>
<li>CGContextRef c 上下文</li>
<li>CGFloat tx 横坐标位移</li>
<li>CGFloat ty 纵坐标位移</li>
</ul>
<p><code>void CGContextTranslateCTM ( CGContextRef c, CGFloat tx, CGFloat ty );</code></p>
</li>
<li><p>// 缩放变换，用于缩放上下文。</p>
<ul>
<li>CGContextRef c 上下文</li>
<li>CGFloat sx 横坐标方向缩放因子（保持原样是1.0）</li>
<li>CGFloat sy 纵坐标方向缩放因子</li>
</ul>
<p><code>void CGContextScaleCTM ( CGContextRef c, CGFloat sx, CGFloat sy );</code></p>
</li>
<li><p>// 缩放变换，用于缩放上下文。</p>
<ul>
<li>CGContextRef c 上下文</li>
<li>CGFloat angel 选择角度（顺时针为正）</li>
</ul>
<p><code>void CGContextRotateCTM ( CGContextRef c, CGFloat angle );</code></p>
</li>
</ul>
<h3 id="7-2-示例"><a href="#7-2-示例" class="headerlink" title="7.2 示例"></a>7.2 示例</h3><ul>
<li><p>以下代码1和效果图1：</p>
<pre><code>CGContextTranslateCTM (myContext, w/4, 0);
   CGContextScaleCTM (myContext, .25,  .5);
   CGContextRotateCTM (myContext, radians ( 22.));
</code></pre></li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图7.1.png?raw=true" alt="图7.1"></p>
<ul>
<li><p>以下代码2和效果图2：</p>
<pre><code>CGContextRotateCTM (myContext, radians ( 22.));
   CGContextScaleCTM (myContext, .25,  .5);
   CGContextTranslateCTM (myContext, w/4, 0);
</code></pre></li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/Quartz2D/图7.2.png?raw=true" alt="图7.2"></p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ol>
<li><a href="http://www.jianshu.com/p/0e785269dccc" target="_blank" rel="external">《Quartz2D》 by Ljson</a></li>
<li><a href="http://www.cnblogs.com/hxwj/p/5217611.html" target="_blank" rel="external">《UIView》 by 幻想无极</a></li>
<li><a href="developer.apple.com/library/etc/redirect/xcode/ios/1151/documentation/UIKit/Reference/UIView_Class/index.html">UIView文档</a></li>
<li><a href="developer.apple.com/library/etc/redirect/xcode/ios/1151/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_overview/dq_overview.html">Quartz 2D文档</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/Allocations使用简介/" itemprop="url">
                  Allocations使用简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-14T21:56:05+08:00" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="官方文档指导"><a href="#官方文档指导" class="headerlink" title="官方文档指导"></a><a href="http//:developer.apple.com/library/etc/redirect/xcode/devtools/1157/recipes/Instruments_help_articles/Articles/FindingAbandonedMemory.html">官方文档指导</a></h3><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><h4 id="启动Allocations"><a href="#启动Allocations" class="headerlink" title="启动Allocations"></a>启动Allocations</h4><pre><code>打开Instruments后，选择Allocations。
进入后左上角选择模拟器和对应要检查的项目。
点击红色圆圈开始检测。
</code></pre><h4 id="总体检测"><a href="#总体检测" class="headerlink" title="总体检测"></a>总体检测</h4><pre><code>启动后整个界面分为上下两块。
下部为App在当前运行的内存使用情况。上部为对应勾选指标的使用情况图示。
指标含义说明：
1. Graph:复选框，勾上展示对应指标图示在上部。
2. Category:检测对象，列出了所有占用内存的持有者。主要关注All Heap Allocations(堆内存分配)和All Anonymous VM（匿名虚拟内存）选项。
3. Persistent Bytes:常驻字节，表示现在内存的占用量。
4. #Persistent:常驻对象数。
5. #Transient:已释放对象数。
6. Total Bytes:App启动分析开始总使用内存。
</code></pre><h4 id="标记检测"><a href="#标记检测" class="headerlink" title="标记检测"></a>标记检测</h4><pre><code>总体检测功能强大，但无法细致看出每个指标的具体变化，这时就可以用标记检测。
在右侧菜单栏选择设置按钮，下有Mark Generation按钮，点击即可进行一次标记检测。
标记检测指标含义说明：
1. Snapshot:快照。表示一次标记的结果，通过小箭头可以查看这次快照下的内存占用的对象分布，并可以找到对应的对象相关代码。
2. timestamp:时间戳，快照时间。
3. Growth:内存相对增长，表示内存相对于上次快照的增长情况。
PS：如果要测试一个页面的内存泄漏情况，在进入界面前Mark一次，pop界面后Mark一次，观察第二次Mark的Growth。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-14T21:33:49+08:00" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/30/JavaWeb开发之MySQL学习笔记/" itemprop="url">
                  JavaWeb开发之MySQL学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-30T11:44:04+08:00" content="2015-12-30">
              2015-12-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/码农之路/" itemprop="url" rel="index">
                    <span itemprop="name">码农之路</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>毕设的题目定了，要做一个简单的web应用。刚好最近在学习Java Web的知识，所学即可用，实在让我欣喜。目前的进度是学习完了基本的基于JSP和Servlet的应用搭建。这俩天在学MySQL，所以今天把学习成果做下笔记，以后忘了也可以看看。特别感谢传智播客的徐仕峰老师的讲解，视频讲得很好。</p>
<p>本文就不再赘述MySQL数据库的优缺点和安装了，这些网上很多资料。主要介绍下基本使用。</p>
<p>本文MarkDown格式有点问题，暂时在解决中…</p>
</blockquote>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ol>
<li>从最基本的CRUD讲起</li>
<li>灵活的数据约束</li>
<li>数据库设计原则</li>
<li>关联查询</li>
<li>函数式操作–存储过程</li>
<li>我是一个观察者–触发器</li>
<li>权限与备份</li>
</ol>
<h3 id="一、从最基本的CRUD讲起"><a href="#一、从最基本的CRUD讲起" class="headerlink" title="一、从最基本的CRUD讲起"></a>一、从最基本的CRUD讲起</h3><blockquote>
<p>所谓CRUD即 增（Create)/查(Retrieve)/改(Update)/删(Delete) 这四种数据库的操作，我们的使用数据库也是基于这四个操作进行的。</p>
<p>以下操作默认在已经安装MySQL的命令行。</p>
<p>SQL语句不区分大小写，一般大写。</p>
</blockquote>
<h4 id="1-1-数据库的CRUD"><a href="#1-1-数据库的CRUD" class="headerlink" title="1.1 数据库的CRUD"></a>1.1 数据库的CRUD</h4><blockquote>
<p>要使用MySQL，需要在电脑上启动其服务器。Mac可以在系统偏好设置中选择MySQL打开服务器。</p>
</blockquote>
<ul>
<li><p>登陆数据库：打开命令行，首先，我们需要使用账号登陆MySQL，对应的账号有对应的权限，我们在安装MySQL时已经注册了账号，这是个最大权限的root账号，这里使用它登陆即可。</p>
<pre><code>mysql -u 账号 -p // 输入完后继续输入密码即可进入MySQL
</code></pre></li>
<li><p>查看数据库：</p>
<pre><code>show databases; // 可以查看数据库，结果如下：
                    （我们看到，这里系统默认帮我们创建了几个数据库）
+--------------------+
| Database           |        
+--------------------+
| information_schema |     // MySQL的元数据和基础数据
| mysql              |        // 存储登陆账号的相关权限信息
| performance_schema |        // MySQL的运行数据和日志信息
| test               |        // 测试用，空
+--------------------+
</code></pre></li>
<li><p>创建数据库：</p>
<pre><code>create database student; // 创建一个student数据库
create database teacher default character set utf8; // 创建一个teacher数据库，默认采用utf8编码的默认字符集。
show create database teacher; // 可以查看数据库默认字符集。
</code></pre></li>
<li><p>删除数据库：</p>
<pre><code>drop database student;
</code></pre></li>
<li><p>修改数据库：</p>
<pre><code>alter database 数据库名 属性 值; 
//示例
alter database teacher default character set gbk; // 修改数据库为gbk字符集编码。 
</code></pre></li>
</ul>
<h4 id="1-2-表的CURD"><a href="#1-2-表的CURD" class="headerlink" title="1.2 表的CURD"></a>1.2 表的CURD</h4><blockquote>
<p>表结构存在于数据库中，在操作表前，首先要选中数据库，使用<code>use 数据库名</code>选中对应数据库，再进行表操作。</p>
</blockquote>
<ul>
<li><p>查看表：</p>
<pre><code>show tables; // 显示数据库的表，这里我创建了一个school数据库use了，这个语句后，提示 Empty set (0.08 sec)，说明数据库为空。
</code></pre></li>
<li><p>创建表：</p>
<pre><code>create table 表名 (字段1 类型, 字段2 类型, ····);

示例： 
mysql&gt; create table student( // 表名为student
-&gt; sid int,                      // 学号字段sid，类型为整形
-&gt; sname varchar(20),          // 姓名字段sname，类型为字符，长度20字节 
-&gt; sage int
-&gt; );
// 这里的格式建议如上，每次写字段或者其他单一操作就换行，结构比较清晰，MySQL语句会识别对应的&apos;;&apos;作为语句的结尾。

// 这里再回来看看这时候show tables的结果。
+------------------+
| Tables_in_school |
+------------------+
| student          |
+------------------+
</code></pre></li>
<li><p>查看表具体结构：</p>
<pre><code>desc student;

+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| sid   | int(11)     | YES  |     | NULL    |       |
| sname | varchar(20) | YES  |     | NULL    |       |
| sage  | int(11)     | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
</code></pre></li>
<li><p>删除表：</p>
<pre><code>drop table student;
</code></pre></li>
<li><p>修改表：（以下操作的<code>column</code>均可省略）</p>
<pre><code>// 添加字段
alter table student add column sgender varchar(2); // 为student表添加一个字符型字段sgender。

// 删除字段 
alter table student drop column sgender; // 删除表的sgender字段。

// 修改字段类型
 alter table student modify column sname varchar(100); // 修改表的sname字段类型为 varchar(100)。

// 修改字段名称
alter table student change column sgender gender varchar(2); // 修改表的sgenser字段为gender。

// 修改表名称
alter table student rename to teacher; // 修改student表的名字为teacher。
</code></pre></li>
</ul>
<h4 id="1-3-数据的CURD"><a href="#1-3-数据的CURD" class="headerlink" title="1.3 数据的CURD"></a>1.3 数据的CURD</h4><ul>
<li><p>增加数据：</p>
<pre><code>// 插入所有字段。一定依次按顺序插入,注意不能少或多字段值.
INSERT INTO student VALUES(1,&apos;David&apos;,20); // 插入了一条数据，分别对应sid、sname、sage。

// 插入部分字段
INSERT INTO student(sid,sname) VALUES(2,&apos;Jack&apos;);
</code></pre></li>
<li><p>删除数据</p>
<pre><code>// 删除所有数据（建议少用）
DELETE FROM student;

// 带条件的删除(推荐使用)
DELETE FROM student WHERE id=2;

// 另一种方式
TRUNCATE TABLE student;

// DELETE 和 TRUNCATE比较
// delete from: 可以全表删除:
// 1)可以带条件删除  
// 2）只能删除表的数据，不能删除表的约束     
// 3)使用delete from删除的数据可以回滚（事务）

// truncate table: 可以全表删除
// 1）不能带条件删除 
// 2）即可以删除表的数据，也可以删除表的约束 
// 3）使用truncate table删除的数据不能回滚
</code></pre></li>
<li><p>查询数据</p>
<pre><code>// 1.查询所有列(字段)
SELECT * FROM student;

// 2.查询指定列
SELECT sid,sname FROM student; // 查询所有学生的学号和姓名。

// 3.查询时添加常量列
SELECT sid,sname,sage,&apos;是&apos; AS &apos;是否应届生&apos;  FROM student; // 查询时为表添加一个字段‘是否应届生’,其值均为常量‘是’。

// 4.查询时合并列
SELECT sid,sname,(math+chinese) AS &apos;总成绩&apos; FROM student; // 查询时为表添加字段‘总成绩’，其值由math（数学成绩）加上chinese(语文成绩)。
// 注意：以上合并的math和chinese必须都是数值类型。

// 5.查询时去除重复记录(DISTINCT)
SELECT DISTINCT sgender FROM student; // sgender字段重复的数据不会显示。
SELECT DISTINCT(sgender) FROM student; // 等价以上

// 6.条件查询

// 6.1 逻辑条件：and(与)、or(或)
SELECT * FROM student WHERE sid=2 AND sname=&apos;David&apos;; // 查找学号为2且名字为David的学生。
SELECT * FROM student WHERE sid=2 OR sname=&apos;David&apos;; // 查找学号为2或名字为David的学生。

// 6.2 比较条件：&gt;、&lt;、&gt;=、&lt;=、=、&lt;&gt;(不等于)、between and (等价于&gt;= 且 &lt;=)
SELECT * FROM student WHERE math&gt;60; // 查找数学成绩大于60的学生。
SELECT * FROM student WHERE math BETWEEN 75 AND 90; // 查找数学成绩大于等于75小于等于90的学生。

// 6.3 判空条件：(null 空字符串)：
    // is null(是否空）
    // is not null(是否不为空)
    // =&apos;&apos;(是否是长度0的字符串)
    // &lt;&gt;&apos;&apos;(是否不是长度为0的字符串)

// 6.4 模糊条件：like
    // 通常使用以下替换标记：
        // % : 表示任意个字符
        // _ : 表示一个字符

SELECT * FROM student WHERE sname LIKE &apos;李%&apos;; // 查找姓‘李’的学生。
SELECT * FROM student WHERE sname LIKE &apos;李_&apos;; // 查找姓为‘李’，名只有一个字的学生。

// 7.聚合查询（使用内置的聚合函数）

// 7.1 SUM(字段)：用于加和
SELECT SUM(math) AS &apos;math的总成绩&apos; FROM student; // 所有学生的数学成绩之和。

// 7.2 AVG(字段)：用于平均
SELECT AVG(math) AS &apos;math的平均分&apos; FROM student; // 所有学生的数学成绩均值。

// 7.3 MIN(字段)、MAX(字段)：求最值
SELECT MAX(math) AS &apos;最高分&apos; FROM student;
SELECT MIN(math) AS &apos;最低分&apos; FROM student;

// 7.4 COUNT(字段)：求数量
SELECT COUNT(*) FROM student; // 统计各字段最多的一个作为返回 
SELECT COUNT(sid) FROM student; // 指定字段数据量，忽略null

// 8.分页查询
SELECT * FROM student LIMIT 0,2; // 查询到的数据中选取从第0条开始的俩条数据。

// 9.查询排序
// 语法 ：order by 字段 asc/desc
// asc: 顺序，正序。数值：递增，字母：自然顺序（a-z）。
// desc: 倒序，反序。数值：递减，字母：自然反序(z-a)。

SELECT * FROM student ORDER BY sid ASC; // 顺序，默认也是这个顺序。

// 10.分组查询
SELECT sgender,COUNT(*) FROM student GROUP BY sgender; // 将学生按性别分组，并输出对应性别人数。

// 11.分组查询后筛选
SELECT sgender,COUNT(*) FROM student WHERE GROUP BY sgender HAVING COUNT(*)&gt;2; // 分组查询后的条件查询使用‘HAVING’关键字。
</code></pre></li>
</ul>
<h3 id="二、灵活的数据约束"><a href="#二、灵活的数据约束" class="headerlink" title="二、灵活的数据约束"></a>二、灵活的数据约束</h3><h4 id="2-1-默认值"><a href="#2-1-默认值" class="headerlink" title="2.1 默认值"></a>2.1 默认值</h4><ul>
<li>作用：当用户对使用默认值的字段<code>不插入</code>值的时候，就使用默认值。</li>
<li><p>注意： 1）对默认值字段插入null是可以的。2）对默认值字段可以插入非null。</p>
<pre><code>CREATE TABLE student( // 在创建表的时候指定。
id INT,
name VARCHAR(20),
address VARCHAR(20) DEFAULT &apos;武汉大学&apos;  // DEFAULT指定默认值。
);
</code></pre></li>
</ul>
<h4 id="2-2-非空"><a href="#2-2-非空" class="headerlink" title="2.2 非空"></a>2.2 非空</h4><ul>
<li>作用： 限制字段必须赋值</li>
<li><p>注意：1）非空字符必须赋值。</p>
<pre><code>2）非空字符不能赋null。

CREATE TABLE student( // 在创建表的时候指定。
id INT,
name VARCHAR(20),
address VARCHAR(20) NOT NULL // 地址不能为空
);    
</code></pre></li>
</ul>
<h4 id="2-3-唯一"><a href="#2-3-唯一" class="headerlink" title="2.3 唯一"></a>2.3 唯一</h4><ul>
<li>作用：对字段的值不能重复</li>
<li><p>注意：1）唯一字段可以插入null。2）唯一字段可以插入多个null。</p>
<pre><code>CREATE TABLE student(
id INT UNIQUE, // 指定id唯一
name VARCHAR(20)
);
</code></pre></li>
</ul>
<h4 id="2-4-主键"><a href="#2-4-主键" class="headerlink" title="2.4 主键"></a>2.4 主键</h4><ul>
<li>作用：非空+唯一</li>
<li><p>注意：1）通常情况下，每张表都会设置一个主键字段。用于标记表中的每条记录的唯一性。</p>
<pre><code>2）建议不要选择表的包含业务含义的字段作为主键，建议给每张表独立设计一个非业务含义的id字段。

CREATE TABLE student(
id INT PRIMARY KEY, // 主键
name VARCHAR(20)
);
</code></pre></li>
</ul>
<h4 id="2-5-自增长"><a href="#2-5-自增长" class="headerlink" title="2.5 自增长"></a>2.5 自增长</h4><ul>
<li><p>作用：自增长字段可以不赋值，自动递增。</p>
<pre><code>CREATE TABLE student(
id INT(4) ZEROFILL PRIMARY KEY AUTO_INCREMENT, // 自增长，从0开始。ZEROFILL，零填充。
name VARCHAR(20)
);
</code></pre></li>
</ul>
<h4 id="2-6-外键"><a href="#2-6-外键" class="headerlink" title="2.6 外键"></a>2.6 外键</h4><ul>
<li><p>作用：1）约束两种表的数据。2）解决数据冗余高问题：独立出一张表</p>
</li>
<li><p>问题描述：见下图，是一个员工表，我们可以看出如果有很多员工都是研发部，那么，每个员工都要存储部门，造成数据冗余，占用较多容量。</p>
</li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/MySQL/MySQL1.png?raw=true" alt="1"></p>
<ul>
<li>为了解决这样一个数据冗余问题，我们可以将这个表拆为两个表，如下：</li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/MySQL/MySQL2.png?raw=true" alt="2"></p>
<p>这样，员工表的部门全部由部门表的depart_id替代，就解决了以上问题。这里我们称部门表为主表，员工表为副表。主表的主键是副表某一字段的外键。</p>
<ul>
<li><p>代码：</p>
<pre><code>// 部门表（主表）
CREATE TABLE dept(
depart_id INT PRIMARY KEY,
depart_name VARCHAR(20)
);

// 修改员工表（副表/从表）
CREATE TABLE employee(
id INT PRIMARY KEY,
name VARCHAR(20),
depart_id INT, // 把部门名称改为部门ID
// 声明一个外键约束
CONSTRAINT emlyee_dept_fk FOREIGN KEY(depart_id) REFERENCES dept(depart_id)            
//           外键名称                  外键               参考表(参考字段)
);
</code></pre></li>
</ul>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ul>
<li>被约束的表称为副表，约束别人的表称为主表，外键设置在副表上的！！！</li>
<li>主表的参考字段通用为主键！</li>
<li>添加数据： 先添加主表，再添加副表</li>
<li>修改数据： 先修改副表，再修改主表</li>
<li>删除数据： 先删除副表，再删除主表</li>
</ul>
<h4 id="2-7-级联操作"><a href="#2-7-级联操作" class="headerlink" title="2.7 级联操作"></a>2.7 级联操作</h4><ul>
<li><p>问题：当有了外键约束的时候，必须先修改或删除副表中的所有关联数据，才能修改或删除主表！但是，我们希望<code>直接修改或删除主表数据</code>，从而影响副表数据。可以使用级联操作实现！！！</p>
<pre><code>CREATE TABLE employee(
id INT PRIMARY KEY,
name VARCHAR(20),
depart_id INT, // 把部门名称改为部门ID
// 声明一个外键约束
CONSTRAINT emlyee_dept_fk FOREIGN KEY(depart_id) REFERENCES dept(depart_id) ON UPDATE CASCADE ON DELETE CASCADE  // ON CASCADE UPDATE ：级联修改
    //          外键名称                  外键               参考表(参考字段)
);

注意： 级联操作必须在外键基础上使用
</code></pre></li>
</ul>
<h3 id="三、-数据库设计原则"><a href="#三、-数据库设计原则" class="headerlink" title="三、 数据库设计原则"></a>三、 数据库设计原则</h3><blockquote>
<p>数据库设计:</p>
<p>业务模型/实体模型 - &gt; 数据模型 (硬盘)，即，先将各种实例进行抽象，再建立对应的表来描述这些抽象。</p>
<h4 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h4></blockquote>
<ul>
<li><p>第一范式： 要求表的<code>每个字段必须是不可分割的独立单元</code></p>
<p>  id  | name<br>  ————- | ————-<br>  1  | 王维恒&amp;David<br>以上违反第一范式，字段name包含了中文名和英文名，不利于查询。</p>
<p>  正确的是：</p>
<p>  id  | name | englishName<br>  ————- | ————- | ———-<br>  1  | 王维恒 | David</p>
</li>
</ul>
<ul>
<li><p>第二范式： 在第一范式的基础上，要求每张表只表达一个意思。表的每个字段都和表的主键有依赖。</p>
<p>  id  | name | math | girlfriend<br>  ————- | ————- | ———- | ——-<br>  1  | 王维恒 | 99 | Fang<br>以上违反第二范式，表及表达了成绩又表达了家人。应该拆成俩个表进行表述。</p>
</li>
</ul>
<ul>
<li>第三范式： 在第二范式基础，要求<code>每张表的主键之外的其他字段都只能和主键有直接决定依赖关系。</code>（反例参考外键约束）<h3 id="四、关联查询（多表查询）"><a href="#四、关联查询（多表查询）" class="headerlink" title="四、关联查询（多表查询）"></a>四、关联查询（多表查询）</h3><blockquote>
<p>多表查询规则：</p>
<p>1）确定查询哪些表<br>2）确定哪些哪些字段<br>3）表与表之间连接条件 (规律：连接条件数量是表数量-1)</p>
</blockquote>
</li>
</ul>
<h4 id="4-1-交叉连接查询（出现笛卡尔积现象）"><a href="#4-1-交叉连接查询（出现笛卡尔积现象）" class="headerlink" title="4.1 交叉连接查询（出现笛卡尔积现象）"></a>4.1 交叉连接查询（出现笛卡尔积现象）</h4><pre><code>// 对于一个员工表（employee），有员工姓名（empName）；对于一个部门表（dept），有部门名字（deptName）。

SELECT empName,deptName FROM employee,dept; // 若有m个员工、n个部门，则返回m * n的结果。
</code></pre><h4 id="4-2-内连接查询：只有满足条件的结果才会显示-使用最频繁"><a href="#4-2-内连接查询：只有满足条件的结果才会显示-使用最频繁" class="headerlink" title="4.2 内连接查询：只有满足条件的结果才会显示(使用最频繁)"></a>4.2 内连接查询：只有满足条件的结果才会显示(使用最频繁)</h4><pre><code>SELECT empName,deptName               // 2）确定哪些哪些字段
    FROM employee,dept                // 1）确定查询哪些表
    WHERE employee.deptId=dept.id;  // 3）表与表之间连接条件
    // (这里指员工表中的部门id与部门表的部门id相等为连接条件，同时符合这个要求的员工表的empName和部门表的deptName将被选出)

// 内连接的另一种语法
SELECT empName,deptName
    FROM employee
    INNER JOIN dept
    ON employee.deptId=dept.id;
</code></pre><h4 id="4-2-左-外-连接查询：-使用左边表的数据去匹配右边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null"><a href="#4-2-左-外-连接查询：-使用左边表的数据去匹配右边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null" class="headerlink" title="4.2 左[外]连接查询： 使用左边表的数据去匹配右边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null"></a>4.2 左[外]连接查询： 使用左边表的数据去匹配右边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null</h4><pre><code>// 注意： 左外连接：左表的数据一定会完成显示！
SELECT d.deptName,e.empName // 这里的e、d为对应表的别名。
    FROM dept d
    LEFT OUTER JOIN employee e
    ON d.id=e.deptId;
</code></pre><h4 id="4-3-右外连接：定义和用法大体同上。"><a href="#4-3-右外连接：定义和用法大体同上。" class="headerlink" title="4.3 右外连接：定义和用法大体同上。"></a>4.3 右外连接：定义和用法大体同上。</h4><h4 id="4-4-自连接查询：在本表中进行匹配。"><a href="#4-4-自连接查询：在本表中进行匹配。" class="headerlink" title="4.4 自连接查询：在本表中进行匹配。"></a>4.4 自连接查询：在本表中进行匹配。</h4><pre><code>SELECT e.empName,b.empName // 查询员工和上级的对应数据
    FROM employee e 
    LEFT OUTER JOIN employee b
    ON e.bossId=b.id;
</code></pre><h3 id="五、-函数式操作–存储过程"><a href="#五、-函数式操作–存储过程" class="headerlink" title="五、 函数式操作–存储过程"></a>五、 函数式操作–存储过程</h3><h4 id="5-1-什么是存储过程"><a href="#5-1-什么是存储过程" class="headerlink" title="5.1 什么是存储过程"></a>5.1 什么是存储过程</h4><blockquote>
<p>存储过程，就是带有逻辑的SQL语句。即可以对SQL进行一些逻辑操作和函数封装。</p>
</blockquote>
<h4 id="5-2-存储过程特点"><a href="#5-2-存储过程特点" class="headerlink" title="5.2 存储过程特点"></a>5.2 存储过程特点</h4><ul>
<li>执行效率非常快！存储过程是在数据库的服务器端执行的！！！</li>
<li>移植性很差！不同数据库的存储过程是不能移植。</li>
</ul>
<h4 id="5-3-存储过程语法"><a href="#5-3-存储过程语法" class="headerlink" title="5.3 存储过程语法"></a>5.3 存储过程语法</h4><ul>
<li><p>创建存储过程</p>
<pre><code>DELIMITER $       // 声明存储过程的结束符
CREATE PROCEDURE pro_test() // 存储过程名称(参数列表)
BEGIN             // 开始
    // 可以写多个sql语句;  
    SELECT * FROM employee; // sql语句+流程控制
END $            // 结束 结束符
</code></pre></li>
<li><p>执行存储过程</p>
<pre><code>// CALL 存储过程名称(参数);
CALL pro_test();  

参数：
    IN：  表示输入参数，可以携带数据带存储过程中
    OUT： 表示输出参数，可以从存储过程中返回结果
    INOUT： 表示输入输出参数，既可以输入功能，也可以输出功能
</code></pre></li>
<li><p>删除存储过程</p>
<pre><code>DROP PROCEDURE pro_test;
</code></pre></li>
</ul>
<ul>
<li><p>存储过程示例</p>
<ol>
<li><p>带输入参数：</p>
<pre><code>DELIMITER $
CREATE PROCEDURE pro_findById(IN eid INT)  // IN: 输入参数
BEGIN
    SELECT * FROM employee WHERE id=eid;
END $ 

// 调用
CALL pro_findById(4);
</code></pre></li>
<li><p>带有输出参数的存储过程</p>
<pre><code>DELIMITER $
CREATE PROCEDURE pro_testOut(OUT str VARCHAR(20))  // OUT：输出参数
BEGIN
    SET str=&apos;hellojava&apos;; // 给参数赋值
END $
</code></pre></li>
<li><p>MySQL的变量：这里在讲带输出参数的存储过程前，我们先来介绍下MySQL中的变量，明显，带有输出参数的函数需要一个变量来接收。这就要用到MySQL的变量了。</p>
<pre><code>1.全局变量（内置变量）：mysql数据库内置的变量 （所有连接都起作用）
     查看所有全局变量： show variables
     查看某个全局变量： select @@变量名
     修改全局变量： set 变量名=新值
     例如：
          character_set_client: mysql服务器的接收数据的编码
         character_set_results：mysql服务器输出数据的编码

2. 会话变量： 只存在于当前客户端与数据库服务器端的一次连接当中。如果连接断开，那么会话变量全部丢失！
    定义会话变量: set @变量=值
    查看会话变量： select @变量

3. 局部变量： 在存储过程中使用的变量就叫局部变量。只要存储过程执行完毕，局部变量就丢失！！

4. 示例：
     1)定义一个会话变量name
     2)使用name会话变量接收存储过程的返回值
        CALL pro_testOut(@name);
        SELECT @name; // 查看变量值
</code></pre></li>
<li><p>带有输入输出参数的存储过程</p>
<pre><code>DELIMITER $
CREATE PROCEDURE pro_testInOut(INOUT n INT)  -- INOUT： 输入输出参数
BEGIN
       SELECT n; // 查看变量
       SET n =500;
END $

SET @n=10;
CALL pro_testInOut(@n);  // 调用
SELECT @n; // n=500
</code></pre></li>
<li><p>带有条件判断的存储过程</p>
<pre><code>DELIMITER $
CREATE PROCEDURE pro_testIf(IN num INT,OUT str VARCHAR(20))
BEGIN
    IF num=1 THEN
        SET str=&apos;星期一&apos;;
    ELSEIF num=2 THEN
        SET str=&apos;星期二&apos;;
    ELSEIF num=3 THEN
        SET str=&apos;星期三&apos;;
    ELSE
        SET str=&apos;输入错误&apos;;
    END IF;
END $

CALL pro_testIf(4,@str);
 SELECT @str;
</code></pre><ol>
<li><p>带有循环功能的存储过程</p>
<p>   DELIMITER $<br>  CREATE PROCEDURE pro_testWhile(IN num INT,OUT result INT)<br>  BEGIN</p>
<pre><code>DECLARE i INT DEFAULT 1; // 定义一个局部变量，类似于for循环的i
DECLARE vsum INT DEFAULT 0;
WHILE i&lt;=num DO
      SET vsum = vsum+i;
      SET i=i+1;
END WHILE;
SET result=vsum;
</code></pre><p>  END $</p>
<p>  CALL pro_testWhile(100,@result);<br>  SELECT @result;</p>
</li>
</ol>
</li>
<li><p>使用查询的结果赋值给变量（INTO）</p>
<pre><code>DELIMITER $
CREATE PROCEDURE pro_findById2(IN eid INT,OUT vname VARCHAR(20) )
BEGIN
    SELECT empName INTO vname FROM employee WHERE id=eid; // 把查询结果赋给vname传出。
END $

CALL pro_findById2(1,@NAME);
SELECT @NAME;
</code></pre></li>
</ol>
</li>
</ul>
<h3 id="六、我是一个观察者–触发器"><a href="#六、我是一个观察者–触发器" class="headerlink" title="六、我是一个观察者–触发器"></a>六、我是一个观察者–触发器</h3><h4 id="6-1-触发器的作用"><a href="#6-1-触发器的作用" class="headerlink" title="6.1 触发器的作用"></a>6.1 触发器的作用</h4><blockquote>
<p>当操作了某张表时，希望同时触发一些动作/行为，可以使用触发器完成！！</p>
</blockquote>
<h4 id="6-2-使用"><a href="#6-2-使用" class="headerlink" title="6.2 使用"></a>6.2 使用</h4><ul>
<li><p>创建触发器(添加)</p>
<pre><code>// 触发器名：tri_empAdd         
// 指定触发动作(CRUD均可)：AFTER INSERT/DELETE/UPDATE
// 指定触发时机（每行）: FOR EACH ROW
CREATE TRIGGER tri_empAdd AFTER INSERT ON employee FOR EACH ROW 
    INSERT INTO test_log(content) VALUES(&apos;员工表插入了一条记录&apos;);  // 这里是触发器触发后行为。模拟一个日志操作。
</code></pre></li>
</ul>
<h3 id="七、权限与备份"><a href="#七、权限与备份" class="headerlink" title="七、权限与备份"></a>七、权限与备份</h3><blockquote>
<p>MySQL数据库权限问题：root（即一开始创建的账户）拥有所有权限（可以干任何事情）。</p>
<p> 权限账户，只拥有部分权限（CURD）例如，只能操作某个数据库的某张表。</p>
</blockquote>
<h4 id="7-1-数据库用户权限管理和密码修改"><a href="#7-1-数据库用户权限管理和密码修改" class="headerlink" title="7.1 数据库用户权限管理和密码修改"></a>7.1 数据库用户权限管理和密码修改</h4><ul>
<li><p>权限管理：前面我们提到，在我们使用MySQL时，系统自动生成了几个数据库，其中有一个MySQL就是用于管理数据库用户的。</p>
<pre><code>在命令行进入MySQL后。
use mysql; 
SELECT * FROM user;
我们可以看到一堆乱码，其实如果你有专门的数据库查看软件，就可以看到，这里有一条记录。大致如下：
</code></pre></li>
</ul>
<table>
<thead>
<tr>
<th>Host</th>
<th>User</th>
<th>Password</th>
<th>·····</th>
</tr>
</thead>
<tbody>
<tr>
<td>localhost</td>
<td>root</td>
<td>28wos988s1928hsh192g7e9s..</td>
<td>·····        </td>
</tr>
</tbody>
</table>
<pre><code>以上这条就是我们的root账号在数据库中存在的具体表达啦，这里指明了访问的host、用户名、密码、各类操作权限等。这里说明下，这个密码是经过单向MD5加密的结果。
操作这个表，我们就能够管理用户了。
</code></pre><ul>
<li><p>分配权限账户：</p>
<pre><code>GRANT SELECT ON company.employee TO &apos;David&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;
// 为用户名David、地址localhost的用户在company数据库下的employee表中赋予了SELECT权限，这里还需给出对应账号密码’123456‘。
</code></pre></li>
</ul>
<ul>
<li><p>密码修改：</p>
<pre><code>// 在上表下，进行下面操作，这里对新密码需要调用内置函数PASSWORD()进行MD5加密。
UPDATE USER SET PASSWORD=PASSWORD(&apos;123456&apos;) WHERE USER=&apos;root&apos;; // 密码改为’123456‘。
</code></pre></li>
</ul>
<h4 id="7-2-数据库备份"><a href="#7-2-数据库备份" class="headerlink" title="7.2 数据库备份"></a>7.2 数据库备份</h4><ul>
<li><p>备份</p>
<pre><code>mysqldump -u root -p 数据库名 &gt; 备份路径;
</code></pre></li>
<li><p>恢复</p>
<pre><code>mysql -u root -p 现在存在的数据库名 &lt; 存在的备份路径;
</code></pre></li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote>
<p>如果发现本文有误，请联系我<a href="mailto:wwhisdavid@163.com" target="_blank" rel="external">wwhisdavid@163.com</a>，谢谢支持。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/16/iOS数据库开发封装、设计与实战/" itemprop="url">
                  iOS数据库开发封装、设计与实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-16T22:17:14+08:00" content="2015-12-16">
              2015-12-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/码农之路/" itemprop="url" rel="index">
                    <span itemprop="name">码农之路</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在我们平常的项目中，经常会碰到数据本地持久化的问题，一般情况，我们是直接调Cocoa的API以普通文件形式进行本地存储。这样的做法对于一般的数据是没有问题的，但是，当我们遇到量比较大的数据时，这种做法将会产生大量IO操作，这是非常影响性能的。并且，这样的做法查询数据十分繁琐，对需要频繁操作数据的开发者十分不友好。所以，当我们需要在应用中频繁操作数据时，我们应该另辟蹊径。这里我选择讲讲数据库和使用设计模式对数据库框架进行封装。</p>
</blockquote>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ol>
<li>iOS上轻量级数据库介绍：SQLite3、LevelDB</li>
<li>iOS数据库开发神器：FMDB</li>
<li>工厂设计模式简介</li>
<li>对FMDB二次封装并带入项目实战：GRDB</li>
<li>SQLite3本地调试</li>
<li>性能讨论</li>
</ol>
<hr>
<h2 id="一、iOS上轻量级数据库介绍：SQLite3、LevelDB"><a href="#一、iOS上轻量级数据库介绍：SQLite3、LevelDB" class="headerlink" title="一、iOS上轻量级数据库介绍：SQLite3、LevelDB"></a>一、iOS上轻量级数据库介绍：SQLite3、LevelDB</h2><h3 id="1-1-SQLite3简介"><a href="#1-1-SQLite3简介" class="headerlink" title="1.1 SQLite3简介"></a>1.1 SQLite3简介</h3><pre><code>    SQLite是一个非常轻量级自包含(lightweight and self-contained)的DBMS，它可移植性好，很容易使用，很小，高效而且可靠。SQLite嵌入到使用它的应用程序中，它们共用相同的进程空间，而不是单独的一个进程。从外部看，它并不像一个RDBMS，但在进程内部，它却是完整的，自包含的数据库引擎。
    嵌入式数据库的一大好处就是在你的程序内部不需要网络配置，也不需要管理。因为客户端和服务器在同一进程空间运行。SQLite 的数据库权限只依赖于文件系统，没有用户帐户的概念。SQLite 有数据库级锁定，没有网络服务器。它需要的内存，其它开销很小，适合用于嵌入式设备。你需要做的仅仅是把它正确的编译到你的程序。
基于这样的考虑，在可移动终端上，我们选用数据库一般就是SQLite3。
</code></pre><h3 id="1-2-在iOS开发中使用SQLite3"><a href="#1-2-在iOS开发中使用SQLite3" class="headerlink" title="1.2 在iOS开发中使用SQLite3"></a>1.2 在iOS开发中使用SQLite3</h3><ol>
<li>在项目中导入包<code>libsqlite3</code>(Xcode已自带，但需自己导入)。</li>
<li>在需要使用数据库的类中导入头文件<code>#import &quot;sqlite3.h&quot;</code></li>
<li><p>实例代码</p>
<pre><code> - (void)testSQL
{
       NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
        NSString *documentsDirectory = [paths objectAtIndex:0];
     NSString *path = [documentsDirectory stringByAppendingPathComponent:@&quot;MyDB.sqlite3&quot;]; // 声明数据库路径

     sqlite3 *db; // 声明数据库
     int status = sqlite3_open(path.UTF8String, &amp;db); // 打开数据库
     if (status == SQLITE_OK) { // 表示打开成功
         const char *sql = &quot;CREATE TABLE IF NOT EXISTS MYTABLE (ID INTEGER PRIMARY KEY AUTOINCREMENT, DATA TEXT)&quot;; // 编辑sql代码，这是一个创表操作。
         char *errorMsg = NULL;
         sqlite3_exec(db, sql, NULL, NULL, &amp;errorMsg); // 执行非查询语句
         if(errorMsg){

         }
         else{

           }
     }

     const char *query = &quot;SELECT ID, DATA FROM FIELDS ORDER BY ROW&quot;; // 查询操作语句（插入相同）

     sqlite3_stmt *statement;

     int status2 = sqlite3_prepare_v2(db, query, -1, &amp;statement, NULL); // 执行查询操作，statement中包含查询结果
     if(status2 == SQLITE_OK)
     {
         while (sqlite3_step(statement) == SQLITE_ROW) {
             const unsigned char *data = sqlite3_column_text(statement, 1); // 执行一次，移动一次step指针 。得到第一列的第一个结果数据。
         }
         sqlite3_finalize(statement);
     }

     //关闭数据库
     sqlite3_close(db);

 } 
</code></pre></li>
</ol>
<h3 id="1-3-LevelDB简介"><a href="#1-3-LevelDB简介" class="headerlink" title="1.3 LevelDB简介"></a>1.3 LevelDB简介</h3><pre><code>对于LevelDB，其实我也没用过，但是早闻大名。这是google开源的一个轻量级数据库。使用了key-value键值对的方式查询和插入，这种方式再配合上了树结构，使它有很高的效率。此外，这是个跨平台的库，OC平台也有封装。
举个例子，我们在需要查询一个县，那么LevelDB会维护一棵树，root是中国，则会根据省、市、县一个个节点进行查询查到这个县。但是，很明显它有个缺点，就是它的快速查询是建立在对key的了如指掌（就像我们在使用二叉树查询时，对二叉树的结构有特定的规则，所以查询时可以达到O(logn)的效率）。
</code></pre><h3 id="参考链接：sqlite3基本使用、-LevelDB基本介绍与使用"><a href="#参考链接：sqlite3基本使用、-LevelDB基本介绍与使用" class="headerlink" title="参考链接：sqlite3基本使用、 LevelDB基本介绍与使用"></a>参考链接：<a href="http://blog.csdn.net/xingxing513234072/article/details/24426307" target="_blank" rel="external">sqlite3基本使用</a>、 <a href="http://www.tanhao.me/pieces/1397.html/" target="_blank" rel="external">LevelDB基本介绍与使用</a></h3><h2 id="二、iOS数据库开发神器：FMDB"><a href="#二、iOS数据库开发神器：FMDB" class="headerlink" title="二、iOS数据库开发神器：FMDB"></a>二、iOS数据库开发神器：FMDB</h2><h3 id="2-1-FMDB简介"><a href="#2-1-FMDB简介" class="headerlink" title="2.1 FMDB简介"></a>2.1 FMDB简介</h3><pre><code>FMDB以OC的方式封装了SQLite的C语言API，大大提高开发数据库效率。相对于Core Data,其具有更高的效率更轻量级，相对于SQLite3，使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码。还有特别好的一点是提供了多线程安全的数据库操作方法，有效地防止数据混乱（数据库的原子性操作是数据安全的核心）。
</code></pre><h3 id="2-2-核心类介绍与基本使用"><a href="#2-2-核心类介绍与基本使用" class="headerlink" title="2.2 核心类介绍与基本使用"></a>2.2 核心类介绍与基本使用</h3><h4 id="2-2-1-FMDatabase"><a href="#2-2-1-FMDatabase" class="headerlink" title="2.2.1 FMDatabase"></a>2.2.1 FMDatabase</h4><pre><code>这是对SQLite3数据进行抽象的类。一个对象代表一个数据库。使用姿势如下：

    FMDatabase *db = [[FMDatabase alloc] initWithPath:path]; // 创建数据库
    [db open]; // 打开
</code></pre><h4 id="2-2-2-FMResultSet"><a href="#2-2-2-FMResultSet" class="headerlink" title="2.2.2 FMResultSet"></a>2.2.2 FMResultSet</h4><pre><code>表示使用FMDatabase执行查询后的结果集,类似于前面的sqlite3_stmt。 更删改查姿势如下：

    FMResultSet *set = [db executeQuery:query]; // 查询
    [db executeUpdate:sql]; // 除查询外操作
    [db executeUpdateWithFormat:@&quot;%@&quot;, ....]; // 带format查询

    while(set.next){
        NSString *name = [set stringForColumn:@&quot;查询字段&quot;]; // 其他详细用法可以看头文件，讲得很详细
    }
</code></pre><h4 id="2-2-3-FMDatabaseQueue"><a href="#2-2-3-FMDatabaseQueue" class="headerlink" title="2.2.3 FMDatabaseQueue"></a>2.2.3 FMDatabaseQueue</h4><pre><code>一个队列类，每个操作放于队列中一次执行，保证了线程安全。

    FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:dbPath];
    [queue inDatabase:^(FMDatabase *db){
        // 操作在此进行
    }
</code></pre><h3 id="参考链接：FMDB简单使用"><a href="#参考链接：FMDB简单使用" class="headerlink" title="参考链接：FMDB简单使用"></a>参考链接：<a href="http://www.cnblogs.com/wendingding/p/3871848.html" target="_blank" rel="external">FMDB简单使用</a></h3><h2 id="三、-工厂设计模式简介"><a href="#三、-工厂设计模式简介" class="headerlink" title="三、 工厂设计模式简介"></a>三、 工厂设计模式简介</h2><h3 id="3-1-为什么还要封装？"><a href="#3-1-为什么还要封装？" class="headerlink" title="3.1 为什么还要封装？"></a>3.1 为什么还要封装？</h3><ul>
<li><p>上面我已经看到了，经过FMDB的封装，数据库操作已经非常友好，我们可以快速简单地进行操作。可是，FMDB只提供了比较基本的封装，要真正在项目中使用还是远远不够的，我想没有人会喜欢频繁地写SQL语句，虽然语法简单但使用起来也是又长又臭。基于编程核心：懒！我们需要对FMDB进行二次封装，使其能够更加简便得使用，更加面向对象。</p>
</li>
<li><p>我们进行框架设计并不是空穴来风，很重要的几点是使用方便、可拓展性强、高内聚低耦合。在我们没有经验的前提下，我们可以借鉴一些经典的设计模式。这里，我们来看看，我们需要封装一个怎样的数据库（目的驱动需求）。</p>
</li>
<li><p>首先，对SQL语句再次封装，不再显式调用而是通过API执行操作。</p>
</li>
<li><p>接着，考虑到需求，我们可能需要在一个数据库中建立多个表来存储不同类目的数据，每次创建表和使用表应该尽量简洁并不对外暴露实现细节。</p>
</li>
<li><p>考虑的需求的多变，我们的数据库表结构应该是多变的，表的增加和减少应该是灵活的，这就要求我们的框架易于拓展。</p>
</li>
<li><p>综合以上，我选择使用工厂模式。</p>
</li>
</ul>
<h3 id="3-2-什么是工厂模式"><a href="#3-2-什么是工厂模式" class="headerlink" title="3.2 什么是工厂模式"></a>3.2 什么是工厂模式</h3><ul>
<li><p>为什么要使用工厂模式呢？首先我们先来介绍下它。</p>
</li>
<li><p>先看看下图：<br><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/FactoryMethod/FactoryMethod.png?raw=true" alt="Factory"></p>
</li>
<li><p>这样有什么好处呢？</p>
</li>
<li><p>首先，客户端只与工厂进行交互，而不用考虑工厂背后的实现。只要告诉工厂需要什么，工厂会调用子工厂进行生产。对外界屏蔽了创建对象的细节。</p>
</li>
<li><p>其次，面向接口编程。对于对象的具体功能，可以在对应的协议中进行规定，统一修改。</p>
</li>
<li><p>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</p>
</li>
<li><p>最重要的是，统一管理对象的创建，当对象的种类增多时，有比较好的代码可读性。</p>
</li>
<li><p>这里，我们可能还看不出工厂模式在应用中的价值，可能你更加习惯直接指定你需要创建的类和对象。但是当你需要创建一群相似类的对象时，在维护时，你可能需要不断在各类头文件中跳来跳去，而使用工厂后，你只要在抽象工厂中排查各个工厂的实现细节。</p>
</li>
<li><p>下面，我们开始讲讲在数据库中实现这样的思路来展现工厂的魅力。</p>
</li>
</ul>
<h2 id="四、-对FMDB二次封装并带入项目实战：GRDB"><a href="#四、-对FMDB二次封装并带入项目实战：GRDB" class="headerlink" title="四、 对FMDB二次封装并带入项目实战：GRDB"></a>四、 对FMDB二次封装并带入项目实战：GRDB</h2><h3 id="4-1-前言"><a href="#4-1-前言" class="headerlink" title="4.1 前言"></a>4.1 前言</h3><ul>
<li>首先，我对FMDB的封装是基于我的一位前辈的框架<a href="https://github.com/greedlab/GreedDB" target="_blank" rel="external">GreedDB</a>。大家可以去git下载，多多星星，或者进入我的github主页，进入Organizations也可以看到我们小队的几个项目。</li>
</ul>
<h3 id="4-2-封装思路与原理"><a href="#4-2-封装思路与原理" class="headerlink" title="4.2 封装思路与原理"></a>4.2 封装思路与原理</h3><ul>
<li><p>本节的DEMO地址 : <a href="https://github.com/wwhisdavid/DBDemo" target="_blank" rel="external">https://github.com/wwhisdavid/DBDemo</a></p>
</li>
<li><p>下面还是先来看张图：</p>
</li>
</ul>
<p><img src="https://github.com/wwhisdavid/MD_Pictures/blob/master/FactoryMethod/DBDemo.png?raw=true" alt="demo"></p>
<ul>
<li><p>什么意思呢？</p>
</li>
<li><p>首先是BaseDao，这是一个为数据库设计的基本协议，用于实现数据库对于表的通用操作。具体方法见协议。</p>
</li>
<li><p>接着，分别有JsonDao和JsonFilterDao两个基础自BaseDao的协议。分别指定数据库对于两种类型的表的操作细节。注意，这一层其实相当于前面我们讲工厂时对于各个工厂的细节约束。</p>
</li>
<li><p>再下来，有两个队列，可以想到，这两个队列充当的角色就是具体执行数据库的操作方，对于其公共父类已经做了FMDatabaseQueue的封装。这两个队列就相当于具体来实现功能的工厂。</p>
</li>
<li><p>左边最上则是我们的抽象工厂了，这里我们发现，抽象工厂与子工厂中还隔了点东西。这里使用了OC特有的分类，让工厂的拓展性淋漓尽致，做到了真正的非侵入式拓展数据库子工厂。为抽象工厂的Category添加一些构造方法，创建遵守了对应数据库协议的队列，让队列与表名一一对应进行管理。将表的管理归结到了对队列的管理，并且由工厂统一派发。</p>
</li>
<li><p>如果你还是觉得云里雾里（我的表述有问题）。来看看workflow。</p>
<pre><code> // 工厂调用分类方法，获取DemoDao对应的队列JsonQueue，接着调用在对应协议中声明的队列操作方法，保存模型到数据库的表中。具体实现，大家可以在队列中和对应协议中看到，不做赘述。
 [[DaoFactory getDemoDao] saveWithModel:model];

// 前段同上，获取到ObjectDao对应的队列（可以认为是表）。接着直接通过key就可以取出对应的模型对应的字典。
 [[DaoFactory getObjectDao] getDictByKey:key];
</code></pre></li>
<li><p>这里，我知道你不禁好奇，存储的机制是什么呢？这里需要说明，该框架是可以做到存储基本数据类型和自定义对象的。因为这里的存储机制是依靠一个类GRDatabaseDefaultModel来实现的。我们将这个需要存储对象的标识符作为唯一主键（key）赋予GRDatabaseDefaultModel对象的key属性。将这个对象的值通过操作转换为JsonString作为value存进了对应的value属性。等于是讲，需要存储的数据进行一次模型封装。</p>
</li>
<li><p>这样的做法基于两点考虑：</p>
<ol>
<li>更加面向对象。</li>
<li>使用对象作为存储中介提高了对数据约束的拓展性。比如，我们需要为表加一个字段做约束，这个字段可能是uid来约束这些数据指展示给对应的用户，那么我们可以为这个model类添加一个字段filter，在对应的创建表操作中稍做修改即可。此外，如果需要表示数据的排序（存储需要排序的数据），我们还可以增加一个字段sort来指定升降序。这些实现已经加在了这个类中。</li>
</ol>
</li>
<li><p>实例代码来一发：</p>
<pre><code> GRDatabaseDefaultModel *model = [[GRDatabaseDefaultModel alloc] init];
for (int i = 0; i &lt; 10; i ++) {
       NSDictionary *tempDict = [self getRandomDict]; // 模拟一个字典
    model.value = tempDict; 
    model.key = [NSNumber numberWithInt:i];
    // filter 和 sort 可以暂时不考虑
    [[DaoFactory getDemoDao] saveWithModel:model];
}
</code></pre></li>
</ul>
<ul>
<li><p>或许你还不理解这个机制的简介与强大，我们来再看看一个表：</p>
<p>  key | value | filter | sort<br>———— | ————- | ————      | ———-<br>1 | JsonString  | guoran  | 1<br>2 | JsonString  | jieshen     | 1     </p>
</li>
<li><p>以上就是这个数据库表的实例结构了。我们在存储时只关心key-value和其他字段。对于value的真正值我们不需要关心。（当然，那个model的解析自然会有框架去做啦）</p>
</li>
</ul>
<h3 id="4-3-实战演练"><a href="#4-3-实战演练" class="headerlink" title="4.3 实战演练"></a>4.3 实战演练</h3><ul>
<li><p>接下来我手把手教一发。</p>
</li>
<li><p>比如现在你要做一个学生管理系统。学生信息有学号和姓名和年纪。你需要存储带本地数据库中。</p>
<ol>
<li>在<code>DaoFactory+NPN</code>中添加方法 <code>+ (id&lt;JsonDao&gt;)getStudentDao</code>。在对于.m文件中实现方法：</li>
</ol>
</li>
</ul>
<pre><code>        + (id&lt;JsonDao&gt;)getObjectDao
        {
            static id&lt;JsonDao&gt; dao = nil;
            static dispatch_once_t onceToken;
            dispatch_once(&amp;onceToken, ^{
                   dao = [[JsonFMDBQueue alloc] initWithTableName:@&quot;Student&quot;];
                });
                return dao;
        }

        // 这样，当你在对应的地方
        Student *s = [Student new];
        s.name = tianming;
        s.age = 25;
        s.id = 110;

        GRDatabaseDefaultModel *model = [[GRDatabaseDefaultModel alloc] init];
        model.key = s.id;
        model.value = s;

        [[DaoFactory getStudentDao] saveWithModel:model];
        // 通过这步，你就完成了向一张名为Student_json的表中插入了一个学生对象，model的key是唯一的学号，value学生真是信息的JsonString。

2. 如果你需要取数据。在对应的地方：

        NSDictionary *dict = [[DaoFactory getStudentDao] getDictByKey:key];
        // 即可取出对应学生对应字典（如果要直接取出对应对象，还需要封装）
</code></pre><ul>
<li><code>更多使用方法可以参考我的demo或者框架的demo。（我和框架的思路不太一样，我为了讲工厂方法所以这样封装，其实用它本来的demo做法也是可以的，读者可自行选择使用策略，个人偏向自己的做法。）</code></li>
</ul>
<h2 id="五、-SQLite3本地调试"><a href="#五、-SQLite3本地调试" class="headerlink" title="五、 SQLite3本地调试"></a>五、 SQLite3本地调试</h2><ul>
<li><p>上面说了怎么在iOS中使用数据库。现在说说怎么调试数据库。在我们使用数据中过程中，我们会遇见很多坑，比如，一句sql语句的语法错误，你可能很难定位。这里框架已经做了处理，由于SQLite3在错误时会抛出错误信息，所以可以在对应的地方打印。</p>
</li>
<li><p>更多的时候，我们会遇见表中数据不符，或者我们也想看看数据库中的内容，这时候怎么办呢？</p>
</li>
<li><p>幸运的是mac内置了对于SQLite3的操作命令。下面来简单介绍下几个常用的调试。</p>
<pre><code>sqlite3 DBName // 在数据库目录下使用，如果存在该数据库，就进入，不存在就创建。

ps1：在sqlite3中的操作命令基本以 . 开头。
ps2：可以在命令行直接写sql语句操作表。（如果这块忘了或比较薄弱可以看看SQL语法，比较简单）

.exit // 退出数据库
.help //查看帮助,针对命令
.database 显示数据库信息,包含当前数据库的位置
.tables 或者 .table 显示数据库所有表名称,没有表则不显示
.schema 命令可以查看创建数据对象时的SQL命令
.schema 表名 查看表字段

select * from 表名; // 查看该表所以数据
...省略，太多啦
</code></pre></li>
</ul>
<h4 id="参考链接：SQLite3语法"><a href="#参考链接：SQLite3语法" class="headerlink" title="参考链接：SQLite3语法"></a>参考链接：<a href="http://blog.csdn.net/linchunhua/article/details/7184439" target="_blank" rel="external">SQLite3语法</a></h4><h2 id="六、-性能讨论"><a href="#六、-性能讨论" class="headerlink" title="六、 性能讨论"></a>六、 性能讨论</h2><ul>
<li><p>说到数据库的性能，其实对于客户端与服务端是没有可比性的。服务端的数据需要面对的高并发和sql注入等问题是客户端基本不会碰到的。所以我们这里谈性能，并不是说数据库本身的负载性能和查询效率。我们讨论的是使用数据库的客户端程序的性能问题。</p>
</li>
<li><p>那么这个问题究竟是什么问题呢？</p>
</li>
<li><p>细心的同学可能已经想到了，就是IO问题。对于移动端这点可怜的内存，大量数据库操作带来的IO会有一定压力的。当然，我们平常是碰不到什么大数据频繁存储的APP，毕竟我们自己的APP也是没有怎么用数据库的。</p>
</li>
<li><p>但是还是想和大家讨论下这个问题，数据库在持久化方面毕竟有它的好处：约束灵活、操作数据灵活等。</p>
</li>
<li><p>关于怎么减少IO对客户端的性能影响，很多人讨论过，不阻塞主线程是基本原则。其他的话，我也想到暂时只能从存取数据的流程上和存储形式上进行优化。这是大家比较容易想到的，如果有其他想法欢迎和我联系<a href="mailto:wwhisdavid@163.com" target="_blank" rel="external">wwhisdavid@163.com</a>。</p>
</li>
<li><p>demo其实写了一半，还有关于多filter的队列还没有时间写，其实JsonQueue已经能满足大部分需求了，如果对相关项目有任何疑问或者bug欢迎联系。</p>
</li>
<li><p>特别感谢GreedDB作者<code>Bell</code>曾经的教导。附上他的邮箱<a href="">bell@greedlab.com</a>。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="王维恒" />
          <p class="site-author-name" itemprop="name">王维恒</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王维恒</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
